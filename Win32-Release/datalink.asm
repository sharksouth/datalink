; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30142.1 

	TITLE	c:\users\sharksouth\onedrive - bupt.edu.cn\学习资料\计算机网络\课程实验\lab1-2022(win+linux)\lab1-windows-vs2019\win32-release\datalink.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CD@DFMNIMLK@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?5windows?5@ ; `string'
PUBLIC	??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0DI@JACPPEIB@Designed?5by?5Jiang?5Yanjun?0?5build@ ; `string'
PUBLIC	??_C@_0BO@BMKHOHKF@?Q?n?J?i?$LK?$KN?5?$LK?z?J?$KF?$LE?$LL?5?$LM?F?M?x?52022?5lab1?6@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ ; `string'
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_frame_expected DB 01H DUP (?)
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ DB '---- DATA %d tim'
	DB	'eout', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@ DB 'Recv NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BMKHOHKF@?Q?n?J?i?$LK?$KN?5?$LK?z?J?$KF?$LE?$LL?5?$LM?F?M?x?52022?5lab1?6@
CONST	SEGMENT
??_C@_0BO@BMKHOHKF@?Q?n?J?i?$LK?$KN?5?$LK?z?J?$KF?$LE?$LL?5?$LM?F?M?x?52022?5lab1?6@ DB 0d1H
	DB	0eeH, 0caH, 0e9H, 0baH, 0adH, ' ', 0baH, 0faH, 0caH, 0a5H, 0b4H
	DB	0bbH, ' ', 0bcH, 0c6H, 0cdH, 0f8H, ' 2022 lab1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JACPPEIB@Designed?5by?5Jiang?5Yanjun?0?5build@
CONST	SEGMENT
??_C@_0DI@JACPPEIB@Designed?5by?5Jiang?5Yanjun?0?5build@ DB 'Designed by '
	DB	'Jiang Yanjun, build: May 12 2022  18:39:06', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@ DB 'Send NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@ DB 'Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DFMNIMLK@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?5windows?5@
CONST	SEGMENT
??_C@_0CD@DFMNIMLK@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?5windows?5@ DB 'S'
	DB	'end DATA %d %d, ID %d windows %d', 0aH, 00H	; `string'
PUBLIC	_main
PUBLIC	_f_between
_ack_expected DB 01H DUP (?)
	ALIGN	4

_phl_ready DD	01H DUP (?)
_buffer	DB	01000H DUP (?)
_next_frame DB	01H DUP (?)
	ALIGN	4

_nbuffered DB	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _f_between
_TEXT	SEGMENT
_c$dead$ = 8						; size = 1
_f_between PROC						; COMDAT
; _a$dead$ = cl
; _b$ = dl

; 29   : 	if (((a <= b) && (b < c)) || ((c < a) && (a <= b)) ||((b < c) && (c < a)))

	mov	cl, BYTE PTR _ack_expected
	mov	al, BYTE PTR _next_frame
	cmp	cl, dl
	ja	SHORT $LN5@f_between
	cmp	dl, al
	jb	SHORT $LN4@f_between
$LN5@f_between:
	cmp	al, cl
	jae	SHORT $LN6@f_between
	cmp	cl, dl
	jbe	SHORT $LN4@f_between
$LN6@f_between:
	cmp	dl, al
	jae	SHORT $LN2@f_between
	cmp	al, cl
	jae	SHORT $LN2@f_between
$LN4@f_between:

; 30   : 		//a:ack_expected,b:f.ack,c:next_frame
; 31   : 		return 1;

	mov	eax, 1

; 34   : }

	ret	0
$LN2@f_between:

; 32   : 	else
; 33   : 		return 0;

	xor	eax, eax

; 34   : }

	ret	0
_f_between ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _put_frame
_TEXT	SEGMENT
_put_frame PROC						; COMDAT
; _frame$ = ecx
; _len$ = edx

; 37   : {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 38   : 	*(unsigned int *)(frame + len) = crc32(frame, len);

	call	_crc32

; 39   : 	send_frame(frame, len + 4);

	lea	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+esi], eax
	mov	ecx, edi
	call	_send_frame

; 40   : 	phl_ready = 0;
; 41   : }

	pop	edi
	mov	DWORD PTR _phl_ready, 0
	pop	esi
	pop	ecx
	ret	0
_put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _send_data_frame
_TEXT	SEGMENT
_s$ = -264						; size = 264
_send_data_frame PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 268				; 0000010cH

; 45   : 	struct FRAME s;
; 46   : 
; 47   : 	s.kind = FRAME_DATA;
; 48   : 	s.seq = next_frame;

	mov	al, BYTE PTR _next_frame

; 49   : 	s.ack = (frame_expected+ MAX_SW) % (MAX_SW + 1);
; 50   : 
; 51   : 	memcpy(s.data, buffer[next_frame], PKT_LEN);

	mov	ecx, 64					; 00000040H
	push	ebx
	movzx	ebx, BYTE PTR _frame_expected
	push	esi
	movzx	edx, al
	dec	ebx
	push	edi
	mov	esi, edx
	mov	BYTE PTR _s$[esp+282], al

; 52   : 	dbg_frame("Send DATA %d %d, ID %d windows %d\n", s.seq, s.ack, *(short *)s.data, nbuffered);

	movzx	eax, BYTE PTR _nbuffered
	lea	edi, DWORD PTR _s$[esp+283]
	shl	esi, 8
	and	ebx, 15					; 0000000fH
	push	eax
	add	esi, OFFSET _buffer
	mov	BYTE PTR _s$[esp+284], 1
	mov	BYTE PTR _s$[esp+285], bl
	rep movsd
	movsx	eax, WORD PTR _s$[esp+287]
	push	eax
	push	ebx
	push	edx
	push	OFFSET ??_C@_0CD@DFMNIMLK@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?5windows?5@
	call	_dbg_frame
	add	esp, 20					; 00000014H

; 53   : 	put_frame((unsigned char *)&s, 3 + PKT_LEN);

	lea	ecx, DWORD PTR _s$[esp+280]
	mov	edx, 259				; 00000103H
	call	_put_frame

; 54   : 	start_timer(next_frame, DATA_TIMER);

	movzx	ecx, BYTE PTR _next_frame
	call	_start_timer

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_send_data_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _send_ack_frame
_TEXT	SEGMENT
_s$ = -264						; size = 264
_send_ack_frame PROC					; COMDAT
; _fe$dead$ = cl

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H

; 59   : 	struct FRAME s;
; 60   : 
; 61   : 	s.kind = FRAME_ACK;
; 62   : 	s.ack = (fe + MAX_SW) % (MAX_SW + 1);
; 63   : 
; 64   : 	dbg_frame("Send ACK  %d\n", s.ack);

	push	15					; 0000000fH
	push	OFFSET ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
	mov	WORD PTR _s$[ebp], 3842			; 00000f02H
	call	_dbg_frame
	add	esp, 8

; 65   : 
; 66   : 	put_frame((unsigned char *)&s, 2);

	lea	ecx, DWORD PTR _s$[ebp]
	mov	edx, 2
	call	_put_frame

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_ack_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _send_nak_frame
_TEXT	SEGMENT
_s$ = -264						; size = 264
_send_nak_frame PROC					; COMDAT
; _fe$dead$ = cl

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H

; 71   : 	struct FRAME s;
; 72   : 
; 73   : 	s.kind = FRAME_NAK;
; 74   : 	s.ack = (fe + MAX_SW) % (MAX_SW + 1);
; 75   : 
; 76   : 	dbg_frame("Send NAK  %d\n", s.ack);

	push	15					; 0000000fH
	push	OFFSET ??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
	mov	WORD PTR _s$[ebp], 3843			; 00000f03H
	call	_dbg_frame
	add	esp, 8

; 77   : 
; 78   : 	put_frame((unsigned char *)&s, 2);

	lea	ecx, DWORD PTR _s$[ebp]
	mov	edx, 2
	call	_put_frame

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_nak_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _main
_TEXT	SEGMENT
_arg$ = -268						; size = 4
_f$ = -264						; size = 264
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 83   : 	int event, arg;
; 84   : 	struct FRAME f;
; 85   : 	int len = 0;
; 86   : 
; 87   : 	protocol_init(argc, argv);

	mov	edx, DWORD PTR _argv$[ebp]
	sub	esp, 272				; 00000110H
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ebx
	push	esi
	call	_protocol_init

; 88   : 	lprintf("Designed by Jiang Yanjun, build: " __DATE__ "  "__TIME__

	push	OFFSET ??_C@_0DI@JACPPEIB@Designed?5by?5Jiang?5Yanjun?0?5build@
	call	_lprintf
	add	esp, 4

; 89   : 		"\n");
; 90   : 	lprintf("杨书涵 胡圣椿 计网 2022 lab1\n");

	push	OFFSET ??_C@_0BO@BMKHOHKF@?Q?n?J?i?$LK?$KN?5?$LK?z?J?$KF?$LE?$LL?5?$LM?F?M?x?52022?5lab1?6@
	call	_lprintf
	add	esp, 4
$LN40@main:

; 91   : 
; 92   : 	disable_network_layer();
; 93   : 
; 94   : 	for (;;) {
; 95   : 		event = wait_for_event(&arg);

	call	_disable_network_layer
	npad	8
$LL2@main:
	lea	ecx, DWORD PTR _arg$[esp+280]
	call	_wait_for_event

; 96   : 		int nak_ = 1;
; 97   : 
; 98   : 		switch (event) {

	cmp	eax, 4
	ja	$LN60@main
	jmp	DWORD PTR $LN57@main[eax*4]
$LN15@main:

; 99   : 		case NETWORK_LAYER_READY:
; 100  : 			get_packet(buffer[next_frame]);

	movzx	ecx, BYTE PTR _next_frame
	shl	ecx, 8
	add	ecx, OFFSET _buffer
	call	_get_packet

; 101  : 			nbuffered++;

	inc	BYTE PTR _nbuffered

; 102  : 			send_data_frame();

	call	_send_data_frame

; 103  : 
; 104  : 			if (next_frame < MAX_SW) //

	mov	al, BYTE PTR _next_frame
	cmp	al, 15					; 0000000fH
	jae	SHORT $LN16@main

; 105  : 				next_frame++;

	inc	al

; 108  : 
; 109  : 			break;

	mov	BYTE PTR _next_frame, al
	jmp	$LN60@main
$LN16@main:

; 106  : 			else
; 107  : 				next_frame = 0;

	xor	al, al

; 108  : 
; 109  : 			break;

	mov	BYTE PTR _next_frame, al
	jmp	$LN60@main
$LN18@main:

; 110  : 
; 111  : 		case PHYSICAL_LAYER_READY:
; 112  : 			phl_ready = 1;

	mov	DWORD PTR _phl_ready, 1

; 113  : 			break;

	jmp	$LN60@main
$LN19@main:

; 114  : 
; 115  : 		case FRAME_RECEIVED:
; 116  : 			len = recv_frame((unsigned char *)&f, sizeof f);

	lea	ecx, DWORD PTR _f$[esp+280]
	call	_recv_frame
	mov	esi, eax

; 117  : 
; 118  : 			if (len < 5 || crc32((unsigned char *)&f, len) != 0) {

	cmp	esi, 5
	jl	$LN21@main
	mov	edx, esi
	lea	ecx, DWORD PTR _f$[esp+280]
	call	_crc32
	test	eax, eax
	jne	$LN21@main

; 126  : 			}
; 127  : 
; 128  : 			if (f.kind == FRAME_ACK) //收到ack 不用操作

	mov	dh, BYTE PTR _f$[esp+280]
	mov	bh, BYTE PTR _f$[esp+281]
	cmp	dh, 2
	jne	SHORT $LN23@main

; 129  : 				dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, bh
	push	eax
	push	OFFSET ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 130  : 
; 131  : 			if (f.kind == FRAME_NAK) //收到nak 重传对应帧

	jmp	$LN63@main
$LN23@main:
	cmp	dh, 3
	jne	SHORT $LN24@main

; 132  : 				dbg_frame("Recv NAK  %d\n", f.ack);

	movzx	eax, bh
	push	eax
	push	OFFSET ??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 133  : 
; 134  : 			if (f.kind ==

	jmp	SHORT $LN63@main
$LN24@main:
	cmp	dh, 1
	jne	SHORT $LN58@main

; 135  : 			    FRAME_DATA) //收到数据 判断是不是所期望的 是：开始ack并传输 不是：发送nak
; 136  : 			{
; 137  : 				dbg_frame("Recv DATA %d %d, ID %d\n", f.seq,f.ack, *(short *)f.data);

	movsx	eax, WORD PTR _f$[esp+283]
	mov	bl, BYTE PTR _f$[esp+282]
	push	eax
	movzx	eax, bh
	push	eax
	movzx	eax, bl
	push	eax
	push	OFFSET ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	_dbg_frame
	add	esp, 16					; 00000010H

; 138  : 				if (f.seq == frame_expected) {

	cmp	bl, BYTE PTR _frame_expected
	jne	SHORT $LN26@main

; 139  : 					put_packet(f.data, len - 7);

	lea	edx, DWORD PTR [esi-7]
	lea	ecx, DWORD PTR _f$[esp+283]
	call	_put_packet

; 140  : 
; 141  : 					if (next_frame < MAX_SW) //

	mov	bl, BYTE PTR _next_frame
	cmp	bl, 15					; 0000000fH
	jae	SHORT $LN28@main

; 142  : 						next_frame++;

	inc	bl

; 145  : 					nak_ = 1;
; 146  : 					start_ack_timer(ACK_TIMER);

	mov	BYTE PTR _next_frame, bl
	call	_start_ack_timer
	mov	dh, BYTE PTR _f$[esp+280]
	jmp	SHORT $LN44@main
$LN28@main:

; 143  : 					else
; 144  : 						next_frame = 0;

	xor	bl, bl

; 145  : 					nak_ = 1;
; 146  : 					start_ack_timer(ACK_TIMER);

	mov	BYTE PTR _next_frame, bl
	call	_start_ack_timer
	mov	dh, BYTE PTR _f$[esp+280]
	jmp	SHORT $LN44@main
$LN26@main:

; 147  : 				} else if (nak_) {
; 148  : 					send_nak_frame(frame_expected);

	call	_send_nak_frame

; 149  : 					nak_ = 0;
; 150  : 					stop_ack_timer();

	call	_stop_ack_timer
$LN63@main:

; 151  : 				}
; 152  : 				//send_ack_frame();
; 153  : 			}
; 154  : 			/*
; 155  : 			if (f.ack == frame_nr) 
; 156  : 			{
; 157  : 				stop_timer(frame_nr);
; 158  : 				nbuffered--;
; 159  : 				frame_nr = 1 - frame_nr;
; 160  : 			}
; 161  : 			*/
; 162  : 
; 163  : 			while (f_between(ack_expected, f.ack, next_frame)) {

	mov	dh, BYTE PTR _f$[esp+280]
$LN58@main:
	mov	bl, BYTE PTR _next_frame
$LN44@main:
	push	ecx
	mov	dl, bh
	call	_f_between
	add	esp, 4
	test	eax, eax
	je	SHORT $LN59@main
	movzx	esi, BYTE PTR _ack_expected
	npad	2
$LL7@main:

; 164  : 				nbuffered--;

	dec	BYTE PTR _nbuffered

; 165  : 				stop_timer(ack_expected);

	mov	ecx, esi
	call	_stop_timer

; 166  : 
; 167  : 				if (next_frame < MAX_SW) //

	cmp	bl, 15					; 0000000fH
	jae	SHORT $LN31@main

; 168  : 					next_frame++;

	inc	bl
	jmp	SHORT $LN32@main
$LN31@main:

; 169  : 				else
; 170  : 					next_frame = 0;

	xor	bl, bl
$LN32@main:

; 151  : 				}
; 152  : 				//send_ack_frame();
; 153  : 			}
; 154  : 			/*
; 155  : 			if (f.ack == frame_nr) 
; 156  : 			{
; 157  : 				stop_timer(frame_nr);
; 158  : 				nbuffered--;
; 159  : 				frame_nr = 1 - frame_nr;
; 160  : 			}
; 161  : 			*/
; 162  : 
; 163  : 			while (f_between(ack_expected, f.ack, next_frame)) {

	push	ecx
	mov	dl, bh
	mov	BYTE PTR _next_frame, bl
	call	_f_between
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL7@main
$LN59@main:

; 171  : 			}
; 172  : 			if (f.kind == FRAME_NAK) //重传开始

	cmp	dh, 3
	jne	$LN60@main

; 173  : 			{
; 174  : 				stop_timer(ack_expected + 1);

	mov	al, BYTE PTR _ack_expected
	movzx	ecx, al
	inc	ecx
	call	_stop_timer

; 175  : 				next_frame = ack_expected;

	mov	BYTE PTR _next_frame, al

; 176  : 				for (int i = 0; i <= nbuffered; i++) {

	xor	esi, esi
	npad	5
$LL11@main:

; 177  : 					send_data_frame(frame_expected);

	movzx	eax, BYTE PTR _frame_expected
	push	eax
	call	_send_data_frame

; 178  : 					start_timer(next_frame, DATA_TIMER);

	movzx	ecx, BYTE PTR _next_frame
	add	esp, 4
	call	_start_timer

; 179  : 					stop_ack_timer();

	call	_stop_ack_timer

; 180  : 
; 181  : 					if (next_frame < MAX_SW) //

	mov	al, BYTE PTR _next_frame
	cmp	al, 15					; 0000000fH
	jae	SHORT $LN34@main

; 182  : 						next_frame++;

	inc	al
	jmp	SHORT $LN9@main
$LN34@main:

; 183  : 					else
; 184  : 						next_frame = 0;

	xor	al, al
$LN9@main:

; 176  : 				for (int i = 0; i <= nbuffered; i++) {

	mov	BYTE PTR _next_frame, al
	inc	esi
	movzx	eax, BYTE PTR _nbuffered
	cmp	esi, eax
	jle	SHORT $LL11@main

; 185  : 				}
; 186  : 				phl_ready = 0;

	mov	DWORD PTR _phl_ready, 0

; 187  : 			}
; 188  : 
; 189  : 			break;

	jmp	$LN60@main
$LN21@main:

; 119  : 				dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	push	OFFSET ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	_dbg_event
	add	esp, 4

; 120  : 				if (nak_) {
; 121  : 					send_nak_frame(frame_expected);

	call	_send_nak_frame

; 122  : 					nak_ = 0;
; 123  : 					stop_ack_timer();
; 124  : 				}
; 125  : 				break;

	jmp	$LN62@main
$LN36@main:

; 190  : 
; 191  : 		case DATA_TIMEOUT:
; 192  : 			dbg_event("---- DATA %d timeout\n", arg);

	push	DWORD PTR _arg$[esp+280]
	push	OFFSET ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	_dbg_event

; 193  : 			next_frame = ack_expected;

	mov	al, BYTE PTR _ack_expected
	add	esp, 8

; 194  : 			for (int i = 1; i <= nbuffered; i++) {

	cmp	BYTE PTR _nbuffered, 1
	mov	esi, 1
	mov	BYTE PTR _next_frame, al
	jb	SHORT $LN13@main
$LL14@main:

; 195  : 				send_data_frame(frame_expected);

	movzx	eax, BYTE PTR _frame_expected
	push	eax
	call	_send_data_frame

; 196  : 				start_timer(next_frame, DATA_TIMER);

	movzx	ecx, BYTE PTR _next_frame
	add	esp, 4
	call	_start_timer

; 197  : 				stop_ack_timer();

	call	_stop_ack_timer

; 198  : 
; 199  : 				if (next_frame < MAX_SW) //

	mov	al, BYTE PTR _next_frame
	cmp	al, 15					; 0000000fH
	jae	SHORT $LN37@main

; 200  : 					next_frame++;

	inc	al
	jmp	SHORT $LN12@main
$LN37@main:

; 201  : 				else
; 202  : 					next_frame = 0;

	xor	al, al
$LN12@main:

; 194  : 			for (int i = 1; i <= nbuffered; i++) {

	mov	BYTE PTR _next_frame, al
	inc	esi
	movzx	eax, BYTE PTR _nbuffered
	cmp	esi, eax
	jle	SHORT $LL14@main
$LN13@main:

; 203  : 			}
; 204  : 			phl_ready = 0;

	mov	DWORD PTR _phl_ready, 0

; 205  : 			break;

	jmp	SHORT $LN60@main
$LN39@main:

; 206  : 
; 207  : 		case ACK_TIMEOUT:
; 208  : 			send_ack_frame(frame_expected);

	call	_send_ack_frame
$LN62@main:

; 209  : 			stop_ack_timer();
; 210  : 			break;
; 211  : 		}
; 212  : 
; 213  : 		if (nbuffered < 1 && phl_ready)

	call	_stop_ack_timer
$LN60@main:
	cmp	BYTE PTR _nbuffered, 1
	jae	$LN40@main
	cmp	DWORD PTR _phl_ready, 0
	je	$LN40@main

; 214  : 			enable_network_layer();

	call	_enable_network_layer
	jmp	$LL2@main
	npad	1
$LN57@main:

; 215  : 		else
; 216  : 			disable_network_layer();
; 217  : 	}
; 218  : }

	DD	$LN15@main
	DD	$LN18@main
	DD	$LN19@main
	DD	$LN36@main
	DD	$LN39@main
_main	ENDP
_TEXT	ENDS
END
