; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30141.0 

	TITLE	c:\users\sharksouth\onedrive\学习资料\计算机网络\课程实验\lab1-2022(win+linux)\lab1-windows-vs2019\win32-release\datalink.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0DI@NKICJKEL@Designed?5by?5Jiang?5Yanjun?0?5build@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ ; `string'
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ DB '---- DATA %d tim'
	DB	'eout', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NKICJKEL@Designed?5by?5Jiang?5Yanjun?0?5build@
CONST	SEGMENT
??_C@_0DI@NKICJKEL@Designed?5by?5Jiang?5Yanjun?0?5build@ DB 'Designed by '
	DB	'Jiang Yanjun, build: Apr 17 2022  12:38:35', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@ DB 'Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Send DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
PUBLIC	_main
_frame_nr DB	01H DUP (?)
	ALIGN	4

_frame_expected DB 01H DUP (?)
	ALIGN	4

_phl_ready DD	01H DUP (?)
_buffer	DB	0100H DUP (?)
_nbuffered DB	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _put_frame
_TEXT	SEGMENT
_put_frame PROC						; COMDAT
; _frame$ = ecx
; _len$ = edx

; 22   : {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 23   : 	*(unsigned int *)(frame + len) = crc32(frame, len);

	call	_crc32

; 24   : 	send_frame(frame, len + 4);

	lea	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+esi], eax
	mov	ecx, edi
	call	_send_frame

; 25   : 	phl_ready = 0;
; 26   : }

	pop	edi
	mov	DWORD PTR _phl_ready, 0
	pop	esi
	pop	ecx
	ret	0
_put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _send_data_frame
_TEXT	SEGMENT
_s$ = -264						; size = 264
_send_data_frame PROC					; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH

; 30   : 	struct FRAME s;
; 31   : 
; 32   : 	s.kind = FRAME_DATA;
; 33   : 	s.seq = frame_nr;
; 34   : 	s.ack = 1 - frame_expected;
; 35   : 	memcpy(s.data, buffer, PKT_LEN);
; 36   : 
; 37   : 	dbg_frame("Send DATA %d %d, ID %d\n", s.seq, s.ack, *(short *)s.data);

	movsx	eax, WORD PTR _buffer
	mov	dl, 1
	sub	dl, BYTE PTR _frame_expected
	mov	ecx, 64					; 00000040H
	push	ebx
	mov	bl, BYTE PTR _frame_nr
	push	esi
	push	edi
	push	eax
	movzx	eax, dl
	lea	edi, DWORD PTR _s$[ebp+3]
	push	eax
	movzx	eax, bl
	mov	esi, OFFSET _buffer
	push	eax
	mov	BYTE PTR _s$[ebp+1], dl
	mov	BYTE PTR _s$[ebp], 1
	mov	BYTE PTR _s$[ebp+2], bl
	rep movsd
	push	OFFSET ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	_dbg_frame
	add	esp, 16					; 00000010H

; 38   : 
; 39   : 	put_frame((unsigned char *)&s, 3 + PKT_LEN);

	lea	ecx, DWORD PTR _s$[ebp]
	mov	edx, 259				; 00000103H
	call	_put_frame

; 40   : 	start_timer(frame_nr, DATA_TIMER);

	movzx	ecx, BYTE PTR _frame_nr
	call	_start_timer

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_send_data_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _send_ack_frame
_TEXT	SEGMENT
_s$ = -264						; size = 264
_send_ack_frame PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H

; 45   : 	struct FRAME s;
; 46   : 
; 47   : 	s.kind = FRAME_ACK;
; 48   : 	s.ack = 1 - frame_expected;

	mov	al, 1
	mov	BYTE PTR _s$[ebp], 2
	sub	al, BYTE PTR _frame_expected
	mov	BYTE PTR _s$[ebp+1], al
	movzx	eax, al

; 49   : 
; 50   : 	dbg_frame("Send ACK  %d\n", s.ack);

	push	eax
	push	OFFSET ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 51   : 
; 52   : 	put_frame((unsigned char *)&s, 2);

	lea	ecx, DWORD PTR _s$[ebp]
	mov	edx, 2
	call	_put_frame

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_ack_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT _main
_TEXT	SEGMENT
_arg$ = -268						; size = 4
_f$ = -264						; size = 264
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 57   : 	int event, arg;
; 58   : 	struct FRAME f;
; 59   : 	int len = 0;
; 60   : 
; 61   : 	protocol_init(argc, argv);

	mov	edx, DWORD PTR _argv$[ebp]
	sub	esp, 272				; 00000110H
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ebx
	push	esi
	call	_protocol_init

; 62   : 	lprintf("Designed by Jiang Yanjun, build: " __DATE__ "  "__TIME__"\n");

	push	OFFSET ??_C@_0DI@NKICJKEL@Designed?5by?5Jiang?5Yanjun?0?5build@
	call	_lprintf
	add	esp, 4
$LN17@main:

; 63   : 
; 64   : 	disable_network_layer();
; 65   : 
; 66   : 	for (;;)
; 67   : 	{
; 68   : 		event = wait_for_event(&arg);

	call	_disable_network_layer
	npad	5
$LL2@main:
	lea	ecx, DWORD PTR _arg$[esp+280]
	call	_wait_for_event

; 69   : 
; 70   : 		switch (event) {

	cmp	eax, 3
	ja	$LN24@main
	jmp	DWORD PTR $LN23@main[eax*4]
$LN7@main:

; 71   : 		case NETWORK_LAYER_READY:
; 72   : 			get_packet(buffer);

	call	_get_packet

; 73   : 			nbuffered++;

	inc	BYTE PTR _nbuffered

; 74   : 			send_data_frame();
; 75   : 			break;

	jmp	$LN25@main
$LN8@main:

; 76   : 
; 77   : 		case PHYSICAL_LAYER_READY:
; 78   : 			phl_ready = 1;

	mov	DWORD PTR _phl_ready, 1

; 79   : 			break;

	jmp	$LN24@main
$LN9@main:

; 80   : 
; 81   : 		case FRAME_RECEIVED:
; 82   : 			len = recv_frame((unsigned char *)&f, sizeof f);

	lea	ecx, DWORD PTR _f$[esp+280]
	call	_recv_frame
	mov	esi, eax

; 83   : 			if (len < 5 || crc32((unsigned char *)&f, len) != 0) {

	cmp	esi, 5
	jl	$LN11@main
	mov	edx, esi
	lea	ecx, DWORD PTR _f$[esp+280]
	call	_crc32
	test	eax, eax
	jne	$LN11@main

; 86   : 			}
; 87   : 			if (f.kind == FRAME_ACK)

	mov	al, BYTE PTR _f$[esp+280]
	mov	bh, BYTE PTR _f$[esp+281]
	cmp	al, 2
	jne	SHORT $LN12@main

; 88   : 				dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, bh
	push	eax
	push	OFFSET ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	_dbg_frame
	add	esp, 8

; 89   : 			if (f.kind == FRAME_DATA) {

	jmp	SHORT $LN13@main
$LN12@main:
	cmp	al, 1
	jne	SHORT $LN13@main

; 90   : 				dbg_frame("Recv DATA %d %d, ID %d\n", f.seq,

	movsx	eax, WORD PTR _f$[esp+283]
	mov	bl, BYTE PTR _f$[esp+282]
	push	eax
	movzx	eax, bh
	push	eax
	movzx	eax, bl
	push	eax
	push	OFFSET ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	_dbg_frame
	add	esp, 16					; 00000010H

; 91   : 					  f.ack, *(short *)f.data);
; 92   : 				if (f.seq == frame_expected) {

	cmp	bl, BYTE PTR _frame_expected
	jne	SHORT $LN14@main

; 93   : 					put_packet(f.data, len - 7);

	lea	edx, DWORD PTR [esi-7]
	lea	ecx, DWORD PTR _f$[esp+283]
	call	_put_packet

; 94   : 					frame_expected = 1 - frame_expected;

	mov	al, 1
	sub	al, BYTE PTR _frame_expected
	mov	BYTE PTR _frame_expected, al
$LN14@main:

; 95   : 				}
; 96   : 				send_ack_frame();

	call	_send_ack_frame
$LN13@main:

; 97   : 			}
; 98   : 			if (f.ack == frame_nr) {

	mov	dl, BYTE PTR _frame_nr
	cmp	bh, dl
	jne	SHORT $LN24@main

; 99   : 				stop_timer(frame_nr);

	movzx	ecx, dl
	call	_stop_timer

; 100  : 				nbuffered--;

	dec	BYTE PTR _nbuffered

; 101  : 				frame_nr = 1 - frame_nr;

	mov	al, 1
	sub	al, dl
	mov	BYTE PTR _frame_nr, al

; 102  : 			}
; 103  : 			break;

	jmp	SHORT $LN24@main
$LN11@main:

; 84   : 				dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	push	OFFSET ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	_dbg_event
	add	esp, 4

; 85   : 				break;

	jmp	SHORT $LN24@main
$LN16@main:

; 104  : 
; 105  : 		case DATA_TIMEOUT:
; 106  : 			dbg_event("---- DATA %d timeout\n", arg);

	push	DWORD PTR _arg$[esp+280]
	push	OFFSET ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	_dbg_event
	add	esp, 8
$LN25@main:

; 107  : 			send_data_frame();
; 108  : 			break;
; 109  : 		}
; 110  : 
; 111  : 		if (nbuffered < 1 && phl_ready)

	call	_send_data_frame
$LN24@main:
	cmp	BYTE PTR _nbuffered, 1
	jae	$LN17@main
	cmp	DWORD PTR _phl_ready, 0
	je	$LN17@main

; 112  : 			enable_network_layer();

	call	_enable_network_layer
	jmp	$LL2@main
	npad	1
$LN23@main:

; 113  : 		else
; 114  : 			disable_network_layer();
; 115  : 	}
; 116  : }

	DD	$LN7@main
	DD	$LN8@main
	DD	$LN9@main
	DD	$LN16@main
_main	ENDP
_TEXT	ENDS
END
