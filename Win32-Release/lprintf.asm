; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30142.1 

	TITLE	c:\users\sharksouth\onedrive - bupt.edu.cn\学习资料\计算机网络\课程实验\lab1-2022(win+linux)\lab1-windows-vs2019\win32-release\lprintf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@		; `string'
PUBLIC	??_C@_0BB@GHIALFFI@0000000000000000@		; `string'
PUBLIC	??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_05MAGFAFAN@?$CInil?$CJ@			; `string'
PUBLIC	??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@	; `string'
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@		; `string'
PUBLIC	??_C@_02MDDDDAID@0x@				; `string'
PUBLIC	??_C@_02FGLHBECB@0X@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	_log_file
EXTRN	_strerror:PROC
EXTRN	_strtol:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	__errno:PROC
EXTRN	_fwrite:PROC
EXTRN	_strtoul:PROC
_log_file DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLHBECB@0X@
CONST	SEGMENT
??_C@_02FGLHBECB@0X@ DB '0X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x@
CONST	SEGMENT
??_C@_02MDDDDAID@0x@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@ DB '(%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
CONST	SEGMENT
??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@ DB '%%%zd.%zd%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAGFAFAN@?$CInil?$CJ@
CONST	SEGMENT
??_C@_05MAGFAFAN@?$CInil?$CJ@ DB '(nil)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB '                '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHIALFFI@0000000000000000@
CONST	SEGMENT
??_C@_0BB@GHIALFFI@0000000000000000@ DB '0000000000000000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
CONST	SEGMENT
??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@ DB '%03d.%03d ', 00H ; `string'
?char_set@?1??output_memory_block@@9@9 DD FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@ ; `output_memory_block'::`2'::char_set
PUBLIC	___v_lprintf
PUBLIC	_sprintf
PUBLIC	__vsprintf_l
PUBLIC	__vsnprintf_l
PUBLIC	_lprintf
?sol@?1??output@@9@9 DD 01H				; `output'::`2'::sol
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _lprintf
_TEXT	SEGMENT
_format$ = 8						; size = 4
_lprintf PROC						; COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp

; 569  :     size_t n;
; 570  :     va_list arg_ptr;
; 571  : 
; 572  :     va_start(arg_ptr, format);
; 573  : 	n = __v_lprintf(format, arg_ptr);

	mov	ecx, DWORD PTR _format$[ebp]
	lea	edx, DWORD PTR _format$[ebp+4]

; 574  :     va_end(arg_ptr);
; 575  : 
; 576  :     return n;
; 577  : }

	pop	ebp

; 569  :     size_t n;
; 570  :     va_list arg_ptr;
; 571  : 
; 572  :     va_start(arg_ptr, format);
; 573  : 	n = __v_lprintf(format, arg_ptr);

	jmp	___v_lprintf
_lprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsnprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$dead$ = edx

; 1391 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1397 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 1458 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1460 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _skip_to
_TEXT	SEGMENT
_skip_to PROC						; COMDAT
; _format$ = ecx

; 32   :     unsigned long i;
; 33   :     for (i = 0; format[i] && format[i] != '%'; ++i);

	mov	dl, BYTE PTR [ecx]
	xor	eax, eax
	test	dl, dl
	je	SHORT $LN3@skip_to
$LL4@skip_to:
	cmp	dl, 37					; 00000025H
	je	SHORT $LN3@skip_to
	mov	dl, BYTE PTR [eax+ecx+1]
	inc	eax
	test	dl, dl
	jne	SHORT $LL4@skip_to
$LN3@skip_to:

; 34   :     return i;
; 35   : }

	ret	0
_skip_to ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _output
_TEXT	SEGMENT
_timestamp$ = -40					; size = 32
_len$1$ = -8						; size = 4
_end$1$ = -4						; size = 4
_output	PROC						; COMDAT
; _str$ = ecx
; _len$ = edx

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _len$1$[ebp], edx
	push	edi

; 45   : 	static bool sol = true; /* start of line */
; 46   : 	unsigned int ms, n;
; 47   : 	char timestamp[32];
; 48   : 	const char *head, *tail, *end = str + len;
; 49   : 
; 50   : 	for (head = tail = str; tail < end; head = tail) {

	mov	ebx, esi
	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR _end$1$[ebp], eax
	cmp	esi, eax
	jae	$LN22@output
	mov	ecx, DWORD PTR ?sol@?1??output@@9@9
$LL5@output:

; 51   : 		while (tail < end && *tail++ != '\n');

	cmp	esi, eax
	jae	SHORT $LN6@output
$LN24@output:
	mov	al, BYTE PTR [esi]
	inc	esi
	cmp	al, 10					; 0000000aH
	mov	eax, DWORD PTR _end$1$[ebp]
	jne	SHORT $LL5@output
$LN6@output:

; 52   : 		if (sol) {

	test	ecx, ecx
	je	SHORT $LN8@output

; 53   : 			ms = get_ms();

	call	_get_ms
	mov	edi, eax

; 54   : 			n = sprintf(timestamp, "%03d.%03d ", ms / 1000, ms % 1000);

	mov	eax, 274877907				; 10624dd3H
	mul	edi
	lea	eax, DWORD PTR _timestamp$[ebp]
	shr	edx, 6
	imul	ecx, edx, 1000
	sub	edi, ecx
	push	edi
	push	edx
	push	OFFSET ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
	push	eax
	call	_sprintf

; 55   : 			tee_output(timestamp, n);

	push	1
	mov	edi, eax
	call	___acrt_iob_func
	add	esp, 20					; 00000014H
	push	eax
	push	edi
	lea	eax, DWORD PTR _timestamp$[ebp]
	push	1
	push	eax
	call	_fwrite
	mov	eax, DWORD PTR _log_file
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN8@output
	push	eax
	push	edi
	lea	eax, DWORD PTR _timestamp$[ebp]
	push	1
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
$LN8@output:

; 56   : 		}
; 57   : 		tee_output(head, tail - head);

	mov	edi, esi
	push	1
	sub	edi, ebx
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	push	edi
	push	1
	push	ebx
	call	_fwrite
	mov	eax, DWORD PTR _log_file
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@output
	push	eax
	push	edi
	push	1
	push	ebx
	call	_fwrite
	add	esp, 16					; 00000010H
$LN10@output:

; 58   : 		sol = tail[-1] == '\n';

	mov	eax, DWORD PTR _end$1$[ebp]
	xor	ecx, ecx
	cmp	BYTE PTR [esi-1], 10			; 0000000aH
	mov	ebx, esi
	sete	cl
	mov	DWORD PTR ?sol@?1??output@@9@9, ecx
	cmp	esi, eax
	jb	$LN24@output

; 59   : 	}
; 60   : 	return len;

	mov	eax, DWORD PTR _len$1$[ebp]

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@output:
	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_output	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _write_pad
_TEXT	SEGMENT
_n$1$ = -4						; size = 4
_write_pad PROC						; COMDAT
; _len$ = ecx
; _pad_ch$ = edx

; 64   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 65   :     const char *pad;
; 66   :     size_t n;
; 67   : 
; 68   :     if ((int)len <= 0) 

	test	esi, esi
	jg	SHORT $LN5@write_pad

; 69   :         return 0;

	xor	eax, eax

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@write_pad:

; 70   : 
; 71   :     if (pad_ch == '0')
; 72   :         pad = "0000000000000000";
; 73   :     else
; 74   :         pad = "                ";
; 75   : 
; 76   :     for (n = 0; len > 15; len -= 16, n += 16) 

	cmp	edx, 48					; 00000030H
	mov	ebx, OFFSET ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
	mov	eax, OFFSET ??_C@_0BB@GHIALFFI@0000000000000000@
	cmove	ebx, eax
	xor	edi, edi
	cmp	esi, 15					; 0000000fH
	jbe	SHORT $LN3@write_pad
	lea	edi, DWORD PTR [esi-16]
	shr	edi, 4
	inc	edi
	mov	eax, edi
	shl	eax, 4
	mov	DWORD PTR _n$1$[ebp], eax
	npad	4
$LL4@write_pad:

; 77   :         output(pad, 16);

	mov	edx, 16					; 00000010H
	mov	ecx, ebx
	call	_output
	sub	esi, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL4@write_pad
	mov	edi, DWORD PTR _n$1$[ebp]
$LN3@write_pad:

; 78   : 
; 79   :     if (len > 0) 

	test	esi, esi
	je	SHORT $LN8@write_pad

; 80   :         n += output(pad, len); 

	mov	edx, esi
	mov	ecx, ebx
	call	_output
	add	edi, eax
$LN8@write_pad:

; 81   : 
; 82   :     return n;

	mov	eax, edi

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_write_pad ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _int64_str
_TEXT	SEGMENT
tv172 = -12						; size = 4
_s$1$ = -8						; size = 4
tv173 = -4						; size = 4
tv295 = 8						; size = 8
_i$ = 8							; size = 8
_i$1$ = 16						; size = 4
_base$ = 16						; size = 4
_upcase$ = 20						; size = 1
_int64_str PROC						; COMDAT
; _s$ = ecx
; _size$ = edx

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ebx, ecx

; 87   :     char *p;
; 88   :     unsigned int j = 0;
; 89   :     
; 90   :     s[--size] = 0; 

	lea	esi, DWORD PTR [edx-1]

; 91   :     
; 92   :     p = s + size;
; 93   :     
; 94   :     if (base == 0 || base > 36) 

	mov	edx, DWORD PTR _base$[ebp]
	add	esi, ebx
	mov	DWORD PTR _s$1$[ebp], ebx
	push	edi
	mov	BYTE PTR [esi], 0
	test	edx, edx
	je	SHORT $LN5@int64_str
	cmp	edx, 36					; 00000024H
	jle	SHORT $LN4@int64_str
$LN5@int64_str:

; 95   :         base = 10;

	mov	edx, 10					; 0000000aH
$LN4@int64_str:

; 96   :     
; 97   :     j = 0;
; 98   :     if (i == 0) {

	mov	ecx, DWORD PTR _i$[ebp]
	xor	edi, edi
	mov	eax, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	or	eax, DWORD PTR _i$[ebp+4]
	jne	SHORT $LN9@int64_str

; 99   :         *(--p) = '0';

	dec	esi

; 100  :         j = 1;

	lea	edi, DWORD PTR [eax+1]
	mov	BYTE PTR [esi], 48			; 00000030H
$LN9@int64_str:

; 101  :     }
; 102  :     
; 103  :     while (p > s && i != 0) {

	cmp	esi, ebx
	jbe	SHORT $LN13@int64_str
	mov	eax, edx
	cdq
	mov	DWORD PTR tv173[ebp], eax
	mov	eax, DWORD PTR _i$[ebp+4]
	mov	DWORD PTR tv172[ebp], edx
	npad	3
$LL2@int64_str:
	or	ecx, eax
	je	SHORT $LN13@int64_str

; 104  :         p--;
; 105  :         *p = (char)(i % base + '0');

	push	ebx
	push	edx
	push	DWORD PTR tv173[ebp]
	dec	esi
	push	eax
	push	DWORD PTR _i$1$[ebp]
	call	__aulldvrm
	mov	DWORD PTR tv295[ebp+4], ebx
	pop	ebx
	mov	ebx, ecx
	mov	ecx, eax
	add	bl, 48					; 00000030H
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	BYTE PTR [esi], bl
	mov	eax, edx

; 106  :         if (*p > '9') 

	cmp	bl, 57					; 00000039H
	jle	SHORT $LN7@int64_str

; 107  :             *p += (upcase ? 'A' : 'a') - '9' - 1;

	cmp	BYTE PTR _upcase$[ebp], 0
	mov	ecx, 39					; 00000027H
	mov	edx, 7
	cmovne	ecx, edx
	add	cl, bl
	mov	BYTE PTR [esi], cl
	mov	ecx, DWORD PTR _i$1$[ebp]
$LN7@int64_str:

; 108  :         i /= base;
; 109  :         j++;

	mov	ebx, DWORD PTR _s$1$[ebp]
	inc	edi
	mov	edx, DWORD PTR tv172[ebp]
	cmp	esi, ebx
	ja	SHORT $LL2@int64_str
$LN13@int64_str:

; 110  :     }
; 111  : 
; 112  :     memmove(s, p, j + 1);

	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	esi
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 113  : 
; 114  :     return j;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_int64_str ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _output_string
_TEXT	SEGMENT
_str$1$ = -8						; size = 4
_size$1$ = -4						; size = 4
_prefix_len$ = 8					; size = 4
_prefix$1$ = 12						; size = 4
_width$ = 12						; size = 4
_precision$ = 16					; size = 4
_flag$ = 20						; size = 4
_pad$ = 24						; size = 1
_precision_pad$ = 28					; size = 1
_output_string PROC					; COMDAT
; _str$ = ecx
; _size$ = edx

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 130  :     const char *prefix;
; 131  :     size_t len = 0;
; 132  :  
; 133  :     if (width == 0 && precision == 0) {

	mov	esi, DWORD PTR _width$[ebp]
	mov	eax, edx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], eax
	mov	DWORD PTR _str$1$[ebp], ecx
	test	esi, esi
	jne	SHORT $LN2@output_str
	test	edx, edx
	jne	SHORT $LN2@output_str

; 134  :         output(str, size); 

	mov	edx, eax
	call	_output

; 135  :         return size;

	mov	eax, DWORD PTR _size$1$[ebp]

; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@output_str:

; 136  :     }
; 137  :     
; 138  :     prefix = str;
; 139  :     
; 140  :     if (prefix_len) {

	mov	ebx, DWORD PTR _prefix_len$[ebp]
	mov	DWORD PTR _prefix$1$[ebp], ecx
	test	ebx, ebx
	je	SHORT $LN3@output_str

; 141  :         str += prefix_len;

	add	ecx, ebx

; 142  :         size -= prefix_len;

	sub	eax, ebx
	mov	DWORD PTR _str$1$[ebp], ecx

; 143  :         width -= prefix_len;

	sub	esi, ebx
	mov	DWORD PTR _size$1$[ebp], eax
$LN3@output_str:

; 144  :     }
; 145  :      
; 146  :     /* These are the cases for 1234 or "1234" respectively:
; 147  :         %.6u -> "001234"
; 148  :         %6u  -> "  1234"
; 149  :         %06u -> "001234"
; 150  :         %-6u -> "1234  "
; 151  :         %.6s -> "1234"
; 152  :         %6s  -> "  1234"
; 153  :         %06s -> "  1234"
; 154  :         %-6s -> "1234  "
; 155  :         %6.5u -> " 01234"
; 156  :         %6.5s -> "  1234"
; 157  :         In this code, for %6.5s, 6 is width, 5 is precision.
; 158  :         flag_dot means there was a '.' and precision is set.
; 159  :         flag_left means there was a '-'.
; 160  :         sz is 4 (strlen("1234")).
; 161  :         pad will be '0' for %06u, ' ' otherwise.
; 162  :         precision_pad is '0' for %u, ' ' for %s.
; 163  :     */
; 164  :     
; 165  :     if ((flag & F_DOT) && width == 0) 

	mov	ecx, DWORD PTR _flag$[ebp]
	test	cl, 64					; 00000040H
	je	SHORT $LN11@output_str
	test	esi, esi
	jne	SHORT $LN5@output_str

; 166  :         width = precision;

	mov	esi, edx

; 167  :     
; 168  :     if (!(flag & F_DOT)) 

	jmp	SHORT $LN5@output_str
$LN11@output_str:

; 169  :         precision = size;

	mov	edx, eax
	mov	DWORD PTR _precision$[ebp], edx
$LN5@output_str:

; 170  : 
; 171  :     /* do left-side padding with spaces */
; 172  :     if (!(flag & F_LEFT) && pad == ' ') 

	and	ecx, 8
	mov	DWORD PTR _flag$[ebp], ecx
	jne	SHORT $LN6@output_str
	cmp	BYTE PTR _pad$[ebp], 32			; 00000020H
	jne	SHORT $LN6@output_str

; 173  :         len += write_pad(width - precision, ' ');

	mov	ecx, esi
	sub	ecx, edx
	mov	edx, 32					; 00000020H
	call	_write_pad
	mov	edi, eax
$LN6@output_str:

; 174  :     
; 175  :     if (prefix_len) {

	test	ebx, ebx
	je	SHORT $LN7@output_str

; 176  :         output(prefix, prefix_len);

	mov	ecx, DWORD PTR _prefix$1$[ebp]
	mov	edx, ebx
	call	_output

; 177  :         len += prefix_len;

	add	edi, ebx
$LN7@output_str:

; 178  :     }
; 179  : 
; 180  :     /* do left-side padding with '0' */
; 181  :     if (!(flag & F_LEFT) && pad == '0') 

	cmp	DWORD PTR _flag$[ebp], 0
	mov	ebx, DWORD PTR _precision$[ebp]
	jne	SHORT $LN8@output_str
	cmp	BYTE PTR _pad$[ebp], 48			; 00000030H
	jne	SHORT $LN8@output_str

; 182  :         len += write_pad(width - precision, '0');

	mov	ecx, esi
	mov	edx, 48					; 00000030H
	sub	ecx, ebx
	call	_write_pad
	add	edi, eax
$LN8@output_str:

; 183  :     
; 184  :     /* do precision padding */
; 185  :     len += write_pad(precision - size, precision_pad);

	movsx	edx, BYTE PTR _precision_pad$[ebp]
	mov	ecx, ebx
	mov	ebx, DWORD PTR _size$1$[ebp]
	sub	ecx, ebx
	call	_write_pad

; 186  :     
; 187  :     /* write actual string */
; 188  :     output(str, size); 

	mov	ecx, DWORD PTR _str$1$[ebp]
	mov	edx, ebx
	add	edi, eax
	call	_output

; 189  :     len += size;

	add	edi, ebx

; 190  : 
; 191  :     /* do right-side padding */
; 192  :     if (flag & F_LEFT) 

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN9@output_str

; 193  :         len += write_pad(width - precision, pad);

	sub	esi, DWORD PTR _precision$[ebp]
	movsx	edx, BYTE PTR _pad$[ebp]
	mov	ecx, esi
	call	_write_pad
	add	edi, eax
$LN9@output_str:

; 194  : 
; 195  :     return len;

	mov	eax, edi

; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_output_string ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _output_integer
_TEXT	SEGMENT
_buf$ = -144						; size = 128
tv391 = -12						; size = 4
_opt_long$1$ = -8					; size = 4
_prefix_len$1$ = -4					; size = 4
_num$ = 8						; size = 8
_is_negative$1$ = 16					; size = 4
_width$ = 16						; size = 4
_s$1$ = 20						; size = 4
_precision$ = 20					; size = 4
_flag$ = 24						; size = 4
_base$ = 28						; size = 4
_prefix$ = 32						; size = 4
_pad$ = 36						; size = 1
_output_integer PROC					; COMDAT
; _opt_long$ = ecx
; _type$ = dl

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx

; 203  :     char buf[128], *s;
; 204  :     size_t sz, prefix_len, n;
; 205  :     bool is_negative;
; 206  : 
; 207  :     if (precision > width) 
; 208  :         width = precision;
; 209  :     
; 210  :     s = buf + 1;

	mov	ebx, DWORD PTR _precision$[ebp]
	lea	eax, DWORD PTR _buf$[ebp+1]
	cmp	ebx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _opt_long$1$[ebp], ecx
	mov	ecx, ebx
	cmovbe	ecx, DWORD PTR _width$[ebp]

; 211  :     if (type == 'p') {

	cmp	dl, 112					; 00000070H
	mov	edx, DWORD PTR _num$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _num$[ebp+4]
	mov	DWORD PTR tv391[ebp], ecx
	mov	DWORD PTR _s$1$[ebp], eax
	jne	SHORT $LN4@output_int

; 212  :         if (num == 0) {

	mov	eax, edx
	or	eax, edi
	jne	SHORT $LN4@output_int

; 213  :             s = "(nil)";
; 214  :             return output_string(s, strlen(s), 0, width, precision, flag, ' ', ' ');

	push	32					; 00000020H
	push	32					; 00000020H
	push	DWORD PTR _flag$[ebp]
	lea	edx, DWORD PTR [eax+5]
	push	ebx
	push	ecx
	push	eax
	mov	ecx, OFFSET ??_C@_05MAGFAFAN@?$CInil?$CJ@

; 266  : }

	call	_output_string
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@output_int:

; 215  :         } 
; 216  :     } 
; 217  : 
; 218  :     strcpy(s, prefix);

	mov	ecx, DWORD PTR _prefix$[ebp]
	lea	esi, DWORD PTR _buf$[ebp+1]
	sub	esi, ecx
$LL24@output_int:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [esi+ecx-1], al
	test	al, al
	jne	SHORT $LL24@output_int

; 219  :     sz = strlen(s);

	lea	esi, DWORD PTR _buf$[ebp+1]
	lea	ecx, DWORD PTR [esi+1]
	npad	6
$LL28@output_int:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL28@output_int

; 220  :     prefix_len = sz;
; 221  :      
; 222  :     is_negative = false;
; 223  :     if (flag & F_SIGN) {

	mov	eax, DWORD PTR _flag$[ebp]
	sub	esi, ecx
	mov	DWORD PTR _prefix_len$1$[ebp], esi
	mov	DWORD PTR _is_negative$1$[ebp], 0
	test	al, 1
	je	SHORT $LN6@output_int

; 224  :         if ((signed __int64)num < 0) {

	test	edi, edi
	jg	SHORT $LN6@output_int
	jl	SHORT $LN29@output_int
	test	edx, edx
	jae	SHORT $LN6@output_int
$LN29@output_int:

; 225  :             num = -(signed __int64)num;

	neg	edx

; 226  :             is_negative = true;

	mov	DWORD PTR _is_negative$1$[ebp], 1
	adc	edi, 0
	neg	edi
$LN6@output_int:

; 227  :         }
; 228  :     } 
; 229  :     
; 230  :     if (opt_long == 1)

	mov	ecx, DWORD PTR _opt_long$1$[ebp]
	cmp	ecx, 1
	je	SHORT $LN32@output_int

; 231  :         num &= (unsigned long)-1;
; 232  :     else if (opt_long == 0)

	test	ecx, ecx
	je	SHORT $LN32@output_int

; 233  :         num &= (unsigned int)-1;
; 234  :     else if (opt_long == -1) 

	cmp	ecx, -1
	jne	SHORT $LN11@output_int

; 235  :         num &= 0xffff;

	movzx	edx, dx
	jmp	SHORT $LN32@output_int
$LN11@output_int:

; 236  :     else if (opt_long == -2) 

	cmp	ecx, -2					; fffffffeH
	jne	SHORT $LN13@output_int

; 237  :         num &= 0xff;

	movzx	edx, dl
$LN32@output_int:

; 238  : 
; 239  :     n = int64_str(s + sz, sizeof(buf) - sz - 1, num, base, flag & F_UPCASE);

	xor	edi, edi
$LN13@output_int:
	and	al, 2
	lea	ecx, DWORD PTR _buf$[ebp+1]
	movzx	eax, al
	add	ecx, esi
	push	eax
	push	DWORD PTR _base$[ebp]
	push	edi
	push	edx
	mov	edx, 127				; 0000007fH
	sub	edx, esi
	call	_int64_str

; 240  : 
; 241  :     /* When 0 is printed with an explicit precision 0, the output is empty. */
; 242  :     if ((flag & F_DOT) && n == 1 && s[sz] == '0') {

	mov	edx, DWORD PTR _flag$[ebp]
	add	esp, 16					; 00000010H
	test	dl, 64					; 00000040H
	je	SHORT $LN14@output_int
	cmp	eax, 1
	jne	SHORT $LN14@output_int
	cmp	BYTE PTR _buf$[ebp+esi+1], 48		; 00000030H
	jne	SHORT $LN14@output_int

; 243  :         if (precision == 0 || prefix_len > 0) 

	test	ebx, ebx
	je	SHORT $LN17@output_int
	test	esi, esi
	je	SHORT $LN16@output_int
$LN17@output_int:

; 244  :             sz = 0;

	xor	esi, esi
$LN16@output_int:

; 245  :         prefix_len = 0;

	xor	eax, eax
	mov	DWORD PTR _prefix_len$1$[ebp], eax

; 246  :     } else 

	jmp	SHORT $LN15@output_int
$LN14@output_int:

; 247  :         sz += n;

	add	esi, eax
$LN15@output_int:

; 248  :     
; 249  :     if (is_negative) {

	cmp	DWORD PTR _is_negative$1$[ebp], 0
	je	SHORT $LN18@output_int

; 250  :         prefix_len = 1;
; 251  :         *(--s) = '-';

	lea	eax, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp], 45			; 0000002dH
	mov	edi, 1
	mov	DWORD PTR _s$1$[ebp], eax

; 252  :         sz++;

	inc	esi
	jmp	SHORT $LN20@output_int
$LN18@output_int:
	test	dl, 48					; 00000030H
	setne	cl
	test	dl, 1
	setne	al
	test	cl, al

; 253  :     } else if ((flag & F_SIGN) && (flag & (F_PLUS | F_SPACE))) {

	je	SHORT $LN30@output_int

; 254  :         prefix_len = 1;
; 255  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	lea	eax, DWORD PTR _buf$[ebp]
	mov	edi, 1
	mov	DWORD PTR _s$1$[ebp], eax
	mov	eax, edx
	and	al, 32					; 00000020H
	neg	al
	sbb	al, al
	and	al, 11					; 0000000bH
	add	al, 32					; 00000020H

; 256  :         sz++;

	inc	esi
	mov	BYTE PTR _buf$[ebp], al
	jmp	SHORT $LN20@output_int
$LN30@output_int:

; 253  :     } else if ((flag & F_SIGN) && (flag & (F_PLUS | F_SPACE))) {

	mov	edi, DWORD PTR _prefix_len$1$[ebp]
$LN20@output_int:

; 257  :     } 
; 258  : 
; 259  :     if (precision > 0)
; 260  :         pad = ' ';
; 261  : 
; 262  :     if (sz - prefix_len > precision)

	movzx	eax, BYTE PTR _pad$[ebp]
	test	ebx, ebx
	mov	ecx, 32					; 00000020H
	cmove	ecx, eax
	mov	eax, esi

; 263  :         precision = sz - prefix_len;
; 264  : 
; 265  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	push	48					; 00000030H
	sub	eax, edi
	push	ecx
	mov	ecx, DWORD PTR _s$1$[ebp]
	cmp	eax, ebx
	push	edx
	cmova	ebx, eax
	mov	edx, esi
	push	ebx
	push	DWORD PTR tv391[ebp]
	push	edi

; 266  : }

	call	_output_string
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_output_integer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _output_double
_TEXT	SEGMENT
_fmt$ = -340						; size = 64
_buf$ = -276						; size = 256
tv291 = -16						; size = 4
tv283 = -12						; size = 4
_type$1$ = -5						; size = 1
_precision$ = 8						; size = 4
_prefix_len$2$ = 12					; size = 4
_flag$ = 12						; size = 4
_pad$ = 16						; size = 4
_d$ = 20						; size = 8
_output_double PROC					; COMDAT
; _type$ = cl
; _width$ = edx

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx

; 271  :     char fmt[64], buf[256], *s, *p;
; 272  :     size_t prefix_len = 0, sz;
; 273  : 
; 274  :     if (width == 0) 
; 275  :         width = 1;
; 276  :     if (!(flag & F_DOT)) 

	mov	ebx, DWORD PTR _flag$[ebp]
	xor	eax, eax
	push	esi
	test	edx, edx
	mov	BYTE PTR _type$1$[ebp], cl
	mov	esi, 1
	xorps	xmm0, xmm0
	mov	ecx, esi
	cmovne	ecx, edx
	test	bl, 64					; 00000040H

; 277  :         precision = 6;
; 278  :     if (d < 0.0) 

	mov	edx, 6
	mov	DWORD PTR tv291[ebp], ecx
	cmovne	edx, DWORD PTR _precision$[ebp]
	comisd	xmm0, QWORD PTR _d$[ebp]
	push	edi
	mov	DWORD PTR tv283[ebp], edx
	cmova	eax, esi
	mov	DWORD PTR _prefix_len$2$[ebp], eax

; 279  :         prefix_len = 1;
; 280  : 
; 281  :     s = buf + 1;
; 282  :     
; 283  :     sprintf(fmt, "%%%zd.%zd%c", width, precision, type);

	movsx	eax, BYTE PTR _type$1$[ebp]
	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR _fmt$[ebp]
	push	OFFSET ??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
	push	eax
	call	_sprintf

; 284  :     sprintf(s, fmt, d);

	movsd	xmm0, QWORD PTR _d$[ebp]
	lea	eax, DWORD PTR _fmt$[ebp]
	add	esp, 12					; 0000000cH
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf$[ebp+1]
	push	eax
	call	_sprintf

; 285  :     
; 286  :     for (p = s; *p == ' '; p++);

	mov	al, BYTE PTR _buf$[ebp+1]
	lea	ecx, DWORD PTR _buf$[ebp+1]
	add	esp, 16					; 00000010H
	cmp	al, 32					; 00000020H
	jne	SHORT $LN3@output_dou
	npad	5
$LL4@output_dou:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 32					; 00000020H
	je	SHORT $LL4@output_dou
$LN3@output_dou:

; 287  : 
; 288  :     for (;;) {
; 289  :         *s = *p;

	mov	BYTE PTR _buf$[ebp+1], al

; 290  :         if (*p == '\0')

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN19@output_dou
	lea	edx, DWORD PTR _buf$[ebp+1]
	sub	edx, ecx
	npad	5
$LL5@output_dou:

; 287  : 
; 288  :     for (;;) {
; 289  :         *s = *p;

	mov	al, BYTE PTR [ecx+1]

; 291  :             break;
; 292  :         s++;
; 293  :         p++;

	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx], al
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL5@output_dou
$LN19@output_dou:

; 294  :     } 
; 295  :     s = buf + 1;

	lea	edi, DWORD PTR _buf$[ebp+1]

; 296  :     sz = strlen(s);

	mov	esi, edi
	lea	ecx, DWORD PTR [esi+1]
	npad	7
$LL26@output_dou:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL26@output_dou
	sub	esi, ecx

; 297  : 
; 298  :     if ((flag & (F_PLUS | F_SPACE)) && d >= 0) {

	test	bl, 48					; 00000030H
	je	SHORT $LN12@output_dou
	movsd	xmm0, QWORD PTR _d$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN12@output_dou

; 299  :         prefix_len = 1;
; 300  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, ebx
	mov	DWORD PTR _prefix_len$2$[ebp], 1
	and	al, 32					; 00000020H
	lea	edi, DWORD PTR _buf$[ebp]
	neg	al
	sbb	al, al
	and	al, 11					; 0000000bH
	add	al, 32					; 00000020H

; 301  :         sz++;

	inc	esi
	mov	BYTE PTR _buf$[ebp], al
$LN12@output_dou:

; 302  :     }
; 303  :     
; 304  :     if ((flag & F_HASH) && type == 'f' && strchr(s, '.') == NULL) 

	test	bl, 4
	je	SHORT $LN13@output_dou
	cmp	BYTE PTR _type$1$[ebp], 102		; 00000066H
	jne	SHORT $LN13@output_dou
	push	46					; 0000002eH
	push	edi
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@output_dou

; 305  :         s[sz++] = '.';

	mov	BYTE PTR [esi+edi], 46			; 0000002eH
	inc	esi
$LN13@output_dou:

; 306  :     
; 307  :     if (width < sz) 
; 308  :         width = sz;
; 309  :     flag &= ~F_DOT;
; 310  :    
; 311  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	push	48					; 00000030H
	push	DWORD PTR _pad$[ebp]
	and	ebx, -65				; ffffffbfH
	mov	eax, esi
	cmp	DWORD PTR tv291[ebp], esi
	mov	edx, esi
	push	ebx
	push	DWORD PTR tv283[ebp]
	cmovae	eax, DWORD PTR tv291[ebp]
	mov	ecx, edi
	push	eax
	push	DWORD PTR _prefix_len$2$[ebp]
	call	_output_string
	add	esp, 24					; 00000018H

; 312  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_output_double ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT _output_memory_block
_TEXT	SEGMENT
_str$ = -264						; size = 256
tv301 = -8						; size = 4
tv300 = -4						; size = 4
_width$ = 8						; size = 4
_precision$ = 12					; size = 4
_flag$ = 16						; size = 4
_pad$ = 20						; size = 4
_output_memory_block PROC				; COMDAT
; _ptr$ = ecx
; _n$ = edx

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	mov	esi, ecx

; 323  :     static const char *char_set = "0123456789abcdef";
; 324  :     char str[256], *s;
; 325  :     size_t len = 0;

	xor	ebx, ebx
	push	edi
	mov	edi, edx

; 326  :     
; 327  :     if (ptr == NULL) 

	test	esi, esi
	jne	SHORT $LN4@output_mem

; 328  :         return output_string("(null)", 6, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	push	DWORD PTR _pad$[ebp]
	lea	edx, DWORD PTR [ecx+6]
	mov	ecx, OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ@
	push	DWORD PTR _flag$[ebp]
	push	DWORD PTR _precision$[ebp]
	push	DWORD PTR _width$[ebp]
	push	ebx
	call	_output_string
	add	esp, 24					; 00000018H

; 358  : 
; 359  :     return len;
; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@output_mem:

; 329  : 
; 330  :     s = str; 
; 331  :     if (flag & F_HASH) 

	test	BYTE PTR _flag$[ebp], 4
	lea	edx, DWORD PTR _str$[ebp]
	je	SHORT $LN5@output_mem

; 332  :         s += sprintf(s, "(%d) ", n);

	push	edi
	mov	eax, edx
	push	OFFSET ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
	push	eax
	call	_sprintf
	lea	edx, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	add	edx, eax
$LN5@output_mem:

; 333  : 
; 334  :     if (n > (sizeof(str) - 32) / 3) 
; 335  :         width = precision = 0;
; 336  :         
; 337  :     while (n > 0) {

	xor	eax, eax
	cmp	edi, 74					; 0000004aH
	cmovbe	eax, DWORD PTR _width$[ebp]
	xor	ecx, ecx
	cmp	edi, 74					; 0000004aH
	mov	DWORD PTR tv300[ebp], eax
	cmovbe	ecx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR tv301[ebp], ecx
	mov	ecx, DWORD PTR _pad$[ebp]
	test	edi, edi
	jle	$LN3@output_mem
$LL2@output_mem:

; 338  :         if (pad != '0' && *ptr < 0x10) 

	cmp	ecx, 48					; 00000030H
	je	SHORT $LN18@output_mem
	mov	al, BYTE PTR [esi]
	cmp	al, 16					; 00000010H
	jae	SHORT $LN18@output_mem

; 339  :             *s++ = char_set[*ptr];

	movzx	eax, al
	mov	al, BYTE PTR ??_C@_0BB@JCEFLFJE@0123456789abcdef@[eax]
	jmp	SHORT $LN20@output_mem
$LN18@output_mem:

; 340  :         else {
; 341  :             *s++ = char_set[*ptr / 16];

	movzx	eax, BYTE PTR [esi]
	shr	eax, 4
	movzx	eax, BYTE PTR ??_C@_0BB@JCEFLFJE@0123456789abcdef@[eax]
	mov	BYTE PTR [edx], al
	inc	edx

; 342  :             *s++ = char_set[*ptr % 16];

	movzx	eax, BYTE PTR [esi]
	and	eax, 15					; 0000000fH
	movzx	eax, BYTE PTR ??_C@_0BB@JCEFLFJE@0123456789abcdef@[eax]
$LN20@output_mem:

; 343  :         }
; 344  : 
; 345  :         n--;

	mov	BYTE PTR [edx], al
	dec	edi
	inc	edx

; 346  :         if (n > 0)

	test	edi, edi
	jle	SHORT $LN9@output_mem

; 347  :             *s++ = ' ';

	mov	BYTE PTR [edx], 32			; 00000020H
	inc	edx
$LN9@output_mem:

; 348  : 
; 349  :         ptr++;
; 350  :         if (s - str > sizeof(str) - 4) {

	lea	ecx, DWORD PTR _str$[ebp]
	mov	eax, edx
	sub	eax, ecx
	inc	esi
	mov	ecx, DWORD PTR _pad$[ebp]
	cmp	eax, 252				; 000000fcH
	jbe	SHORT $LN19@output_mem

; 351  :             len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	push	ecx
	push	DWORD PTR _flag$[ebp]
	mov	edx, eax
	lea	ecx, DWORD PTR _str$[ebp]
	push	DWORD PTR tv301[ebp]
	push	DWORD PTR tv300[ebp]
	push	0
	call	_output_string

; 352  :             s = str;

	mov	ecx, DWORD PTR _pad$[ebp]
	lea	edx, DWORD PTR _str$[ebp]
	add	esp, 24					; 00000018H
	add	ebx, eax
$LN19@output_mem:

; 333  : 
; 334  :     if (n > (sizeof(str) - 32) / 3) 
; 335  :         width = precision = 0;
; 336  :         
; 337  :     while (n > 0) {

	test	edi, edi
	jg	$LL2@output_mem
	mov	eax, DWORD PTR tv300[ebp]
$LN3@output_mem:

; 353  :         }
; 354  :     }
; 355  : 
; 356  :     if (s != str) 

	lea	esi, DWORD PTR _str$[ebp]
	cmp	edx, esi
	je	SHORT $LN11@output_mem

; 357  :         len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	push	32					; 00000020H
	push	ecx
	push	DWORD PTR _flag$[ebp]
	mov	ecx, esi
	push	DWORD PTR tv301[ebp]
	push	eax
	mov	eax, esi
	push	0
	sub	edx, eax
	call	_output_string
	add	esp, 24					; 00000018H
	add	ebx, eax
$LN11@output_mem:

; 358  : 
; 359  :     return len;
; 360  : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_output_memory_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT ___v_lprintf
_TEXT	SEGMENT
_ch$ = -38						; size = 1
_ch$1$ = -37						; size = 1
_arg_ptr$1$ = -36					; size = 4
_len$1$ = -32						; size = 4
_s$ = -28						; size = 4
_prefix$1$ = -24					; size = 4
_precision$1$ = -20					; size = 4
_base$1$ = -16						; size = 4
tv497 = -16						; size = 4
_num$1$ = -12						; size = 4
tv527 = -12						; size = 4
_opt_long$1$ = -12					; size = 4
_pad$ = -8						; size = 1
_err$1$ = -4						; size = 4
___v_lprintf PROC					; COMDAT
; _format$ = ecx
; _arg_ptr$ = edx

; 363  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi

; 364  :     size_t len = 0, l;

	xor	ebx, ebx
	mov	DWORD PTR _arg_ptr$1$[esp+60], edx
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _len$1$[esp+64], ebx

; 365  :     signed int n;
; 366  :     int err = errno;

	call	__errno
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _err$1$[esp+64], eax

; 367  :     char *s;
; 368  :     unsigned char *ptr;
; 369  :     int flag;
; 370  :     char ch, pad;
; 371  :     
; 372  :     signed int opt_long;
; 373  : 
; 374  :     unsigned int base;
; 375  :     size_t width, precision;
; 376  :     
; 377  :     __int64 num;
; 378  :     char *prefix;
; 379  : 
; 380  :     while (*format) {

	cmp	BYTE PTR [esi], bl
	je	$LN90@v_lprintf
	npad	5
$LL2@v_lprintf:

; 381  :         
; 382  :         n = skip_to(format);

	mov	ecx, esi
	call	_skip_to
	mov	edi, eax

; 383  :         if (n) {

	test	edi, edi
	je	SHORT $LN6@v_lprintf

; 384  :             output(format, n); 

	mov	edx, edi
	call	_output

; 385  :             len += n;

	add	ebx, edi

; 386  :             format += n;

	add	esi, edi
	mov	DWORD PTR _len$1$[esp+64], ebx
$LN6@v_lprintf:

; 387  :         }
; 388  :         
; 389  :         if (*format != '%') 

	cmp	BYTE PTR [esi], 37			; 00000025H
	jne	$LN65@v_lprintf

; 390  :             continue;
; 391  :         
; 392  :         pad = ' ';
; 393  :         flag = 0;
; 394  :         opt_long = 0;
; 395  :         prefix = "";
; 396  :         
; 397  :         width = 0;
; 398  :         precision = 0;
; 399  :         num = 0;
; 400  :         
; 401  :         ++format;
; 402  :         
; 403  : next_option:
; 404  :         switch (ch = *format++) {

	mov	dl, BYTE PTR [esi+1]
	mov	eax, 32					; 00000020H
	mov	DWORD PTR tv497[esp+64], eax
	xor	ecx, ecx
	mov	BYTE PTR _pad$[esp+64], al
	xor	ebx, ebx
	xor	eax, eax
	mov	DWORD PTR _opt_long$1$[esp+64], ecx
	mov	DWORD PTR _precision$1$[esp+64], eax
	xor	edi, edi
	movsx	eax, dl
	add	esi, 2
	mov	DWORD PTR _prefix$1$[esp+64], OFFSET ??_C@_00CNPNBAHC@@
	mov	BYTE PTR _ch$1$[esp+64], dl
	mov	BYTE PTR _ch$[esp+64], dl
	cmp	eax, 122				; 0000007aH
	ja	$LN95@v_lprintf
	npad	12
$next_option$100:
	movzx	eax, BYTE PTR $LN91@v_lprintf[eax]
	jmp	DWORD PTR $LN92@v_lprintf[eax*4]
$LN9@v_lprintf:

; 405  :         case 0:
; 406  :             return -1;
; 407  :             break;
; 408  :             
; 409  :         /* FLAGS */
; 410  :         case '#':
; 411  :             flag |= F_HASH;

	or	ebx, 4

; 412  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN10@v_lprintf:

; 413  : 
; 414  :         case 'h':
; 415  :             --opt_long;

	dec	ecx
	mov	DWORD PTR _opt_long$1$[esp+64], ecx

; 416  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN11@v_lprintf:

; 417  :             
; 418  :         case 'q':     
; 419  :         case 'L':
; 420  :             ++opt_long;

	inc	ecx
$LN13@v_lprintf:

; 421  :         case 'z':
; 422  :         case 'l':
; 423  :             ++opt_long;

	inc	ecx
	mov	DWORD PTR _opt_long$1$[esp+64], ecx

; 424  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN15@v_lprintf:

; 425  :             
; 426  :         case '-':
; 427  :             flag |= F_LEFT;

	or	ebx, 8

; 428  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN16@v_lprintf:

; 429  :             
; 430  :         case ' ':
; 431  :             flag |= F_SPACE;

	or	ebx, 16					; 00000010H

; 432  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN17@v_lprintf:

; 433  :             
; 434  :         case '+':
; 435  :             flag |= F_PLUS;

	or	ebx, 32					; 00000020H

; 436  :             goto next_option;

	jmp	$LN37@v_lprintf
$LN18@v_lprintf:

; 437  :             
; 438  :         case '0':
; 439  :         case '1':
; 440  :         case '2':
; 441  :         case '3':
; 442  :         case '4':
; 443  :         case '5':
; 444  :         case '6':
; 445  :         case '7':
; 446  :         case '8':
; 447  :         case '9':
; 448  :             if (flag & F_DOT) 

	test	bl, 64					; 00000040H
	jne	$LN83@v_lprintf

; 449  :                 return -1;
; 450  :             width = strtoul(format - 1, (char **)&s, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[esp+68]
	push	eax
	lea	eax, DWORD PTR [esi-1]
	push	eax
	call	_strtoul
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 451  :             if (width > MAX_WIDTH) 

	cmp	edi, 10240				; 00002800H
	ja	$LN83@v_lprintf

; 452  :                 return -1;
; 453  :             if (ch == '0' && !(flag & F_LEFT)) 

	cmp	BYTE PTR _ch$[esp+64], 48		; 00000030H
	jne	SHORT $LN30@v_lprintf
	mov	eax, DWORD PTR tv497[esp+64]
	test	bl, 8
	movzx	eax, al
	mov	ecx, 48					; 00000030H
	cmove	eax, ecx
	mov	DWORD PTR tv497[esp+64], eax
	mov	BYTE PTR _pad$[esp+64], al
$LN30@v_lprintf:

; 454  :                 pad = '0';
; 455  :             format = s;

	mov	esi, DWORD PTR _s$[esp+64]

; 456  :             goto next_option;

	jmp	SHORT $LN37@v_lprintf
$LN31@v_lprintf:

; 457  :             
; 458  :         case '*': 
; 459  :             if ((n = va_arg(arg_ptr, int)) < 0) {

	mov	ecx, DWORD PTR _arg_ptr$1$[esp+64]
	add	ecx, 4
	mov	DWORD PTR _arg_ptr$1$[esp+64], ecx
	mov	edi, DWORD PTR [ecx-4]
	test	edi, edi
	jns	SHORT $LN89@v_lprintf

; 460  :                 flag |= F_LEFT;

	or	ebx, 8

; 461  :                 n = -n;

	neg	edi
$LN89@v_lprintf:

; 462  :             }
; 463  :             if ((width = (unsigned long)n) > MAX_WIDTH) 

	cmp	edi, 10240				; 00002800H

; 464  :                 return -1;
; 465  :             goto next_option; 

	jmp	SHORT $LN96@v_lprintf
$LN34@v_lprintf:

; 466  :             
; 467  :         case '.':
; 468  :             flag |= F_DOT;

	or	ebx, 64					; 00000040H

; 469  :             if (*format == '*') {

	cmp	BYTE PTR [esi], 42			; 0000002aH
	jne	SHORT $LN35@v_lprintf

; 470  :                 n = va_arg(arg_ptr, int);

	mov	eax, DWORD PTR _arg_ptr$1$[esp+64]
	add	eax, 4

; 471  :                 ++format;

	inc	esi
	mov	DWORD PTR _arg_ptr$1$[esp+64], eax
	mov	eax, DWORD PTR [eax-4]

; 472  :             } else {

	jmp	SHORT $LN36@v_lprintf
$LN35@v_lprintf:

; 473  :                 n = strtol(format, (char**)&s, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _s$[esp+68]
	push	eax
	push	esi
	call	_strtol

; 474  :                 format = s;

	mov	esi, DWORD PTR _s$[esp+76]
	add	esp, 12					; 0000000cH
$LN36@v_lprintf:

; 475  :             }
; 476  :             precision = n < 0 ? 0 : n;

	xor	ecx, ecx
	test	eax, eax
	cmovs	eax, ecx
	mov	DWORD PTR _precision$1$[esp+64], eax

; 477  :             if (precision > MAX_WIDTH) 

	cmp	eax, 10240				; 00002800H
$LN96@v_lprintf:

; 390  :             continue;
; 391  :         
; 392  :         pad = ' ';
; 393  :         flag = 0;
; 394  :         opt_long = 0;
; 395  :         prefix = "";
; 396  :         
; 397  :         width = 0;
; 398  :         precision = 0;
; 399  :         num = 0;
; 400  :         
; 401  :         ++format;
; 402  :         
; 403  : next_option:
; 404  :         switch (ch = *format++) {

	ja	$LN83@v_lprintf
$LN37@v_lprintf:
	mov	al, BYTE PTR [esi]
	inc	esi
	mov	ecx, DWORD PTR _opt_long$1$[esp+64]
	mov	dl, al
	mov	BYTE PTR _ch$1$[esp+64], al
	mov	BYTE PTR _ch$[esp+64], al
	movsx	eax, dl
	cmp	eax, 122				; 0000007aH
	jbe	$next_option$100
$LN95@v_lprintf:

; 367  :     char *s;
; 368  :     unsigned char *ptr;
; 369  :     int flag;
; 370  :     char ch, pad;
; 371  :     
; 372  :     signed int opt_long;
; 373  : 
; 374  :     unsigned int base;
; 375  :     size_t width, precision;
; 376  :     
; 377  :     __int64 num;
; 378  :     char *prefix;
; 379  : 
; 380  :     while (*format) {

	mov	ebx, DWORD PTR _len$1$[esp+64]
$LN65@v_lprintf:
	cmp	BYTE PTR [esi], 0
	jne	$LL2@v_lprintf
$LN90@v_lprintf:

; 557  :                 width, precision, flag, pad); 
; 558  :             break; 
; 559  : 
; 560  :         default:
; 561  :             break;
; 562  :         }
; 563  :     }
; 564  :     return len;

	mov	eax, ebx

; 565  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@v_lprintf:

; 478  :                 return -1;
; 479  :             goto next_option;
; 480  :             
; 481  :         /* print a char or % */
; 482  :         case 'c':
; 483  :             ch = (char)va_arg(arg_ptr, int);

	mov	edx, DWORD PTR _arg_ptr$1$[esp+64]
	add	edx, 4
	mov	DWORD PTR _arg_ptr$1$[esp+64], edx
	mov	al, BYTE PTR [edx-4]
	mov	BYTE PTR _ch$[esp+64], al
$LN39@v_lprintf:

; 484  :         case '%':
; 485  :             output(&ch, 1); 

	mov	edx, 1
	lea	ecx, DWORD PTR _ch$[esp+64]
	call	_output

; 486  :             ++len;

	mov	ebx, DWORD PTR _len$1$[esp+64]
	inc	ebx
	mov	DWORD PTR _len$1$[esp+64], ebx

; 487  :             break;

	jmp	SHORT $LN65@v_lprintf
$LN40@v_lprintf:

; 488  :                        
; 489  :         /* print a string */
; 490  :         case 'm':
; 491  :         case 's':
; 492  :             s = ch == 'm' ? strerror(err) : va_arg(arg_ptr, char *);

	cmp	dl, 109					; 0000006dH
	jne	SHORT $LN67@v_lprintf
	push	DWORD PTR _err$1$[esp+64]
	call	_strerror
	add	esp, 4
	mov	ecx, eax
	jmp	SHORT $LN68@v_lprintf
$LN67@v_lprintf:
	mov	edx, DWORD PTR _arg_ptr$1$[esp+64]
	add	edx, 4
	mov	DWORD PTR _arg_ptr$1$[esp+64], edx
	mov	ecx, DWORD PTR [edx-4]
$LN68@v_lprintf:

; 493  :             if (s == NULL) 

	mov	DWORD PTR _s$[esp+64], ecx
	mov	edx, ecx
	test	ecx, ecx
	jne	SHORT $LN42@v_lprintf

; 494  :                 s = "(null)";

	mov	ecx, OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ@
	mov	DWORD PTR _s$[esp+64], ecx
	mov	edx, ecx
$LN42@v_lprintf:

; 495  :             l = strlen(s);

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR tv527[esp+64], eax
$LL93@v_lprintf:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL93@v_lprintf
	sub	edx, DWORD PTR tv527[esp+64]

; 496  :             if ((flag & F_DOT) && l > precision) 

	test	bl, 64					; 00000040H
	je	SHORT $LN43@v_lprintf
	cmp	edx, DWORD PTR _precision$1$[esp+64]
	cmova	edx, DWORD PTR _precision$1$[esp+64]
$LN43@v_lprintf:

; 497  :                 l = precision;
; 498  :             flag &= ~F_DOT;
; 499  :             len += output_string(s, l, 0, width, 0, flag, ' ', ' ');

	push	32					; 00000020H
	push	32					; 00000020H
	and	ebx, -65				; ffffffbfH
	push	ebx
	push	0
	push	edi
	push	0
	call	_output_string
	mov	ebx, DWORD PTR _len$1$[esp+88]
	add	esp, 24					; 00000018H
	add	ebx, eax
	mov	DWORD PTR _len$1$[esp+64], ebx

; 500  :             break;

	jmp	$LN65@v_lprintf
$LN44@v_lprintf:

; 501  :              
; 502  :         /* print an integer value */
; 503  :         case 'b':
; 504  :             base = 2;

	mov	DWORD PTR _base$1$[esp+64], 2

; 505  :             goto print_num;

	jmp	SHORT $print_num$101
$LN45@v_lprintf:

; 506  :             
; 507  :         case 'p':
; 508  :             prefix = "0x";

	mov	DWORD PTR _prefix$1$[esp+64], OFFSET ??_C@_02MDDDDAID@0x@

; 509  :             opt_long = sizeof(void *) / sizeof(long);

	mov	ecx, 1
$LN46@v_lprintf:

; 510  :         case 'X':
; 511  :             if (ch == 'X')

	cmp	dl, 88					; 00000058H
	jne	SHORT $LN47@v_lprintf

; 512  :                 flag |= F_UPCASE;

	or	ebx, 2
$LN47@v_lprintf:

; 513  :         case 'x':
; 514  :             base = 16;

	mov	DWORD PTR _base$1$[esp+64], 16		; 00000010H

; 515  :             if (flag & F_HASH) 

	test	bl, 4
	je	SHORT $print_num$101

; 516  :                 prefix = ch == 'X' ? "0X" : "0x";

	cmp	dl, 88					; 00000058H
	mov	eax, OFFSET ??_C@_02FGLHBECB@0X@
	mov	edx, OFFSET ??_C@_02MDDDDAID@0x@
	cmovne	eax, edx

; 517  :             goto print_num;

	jmp	SHORT $LN97@v_lprintf
$LN50@v_lprintf:

; 518  :             
; 519  :         case 'd':
; 520  :         case 'i': 
; 521  :             flag |= F_SIGN;

	or	ebx, 1
$LN52@v_lprintf:

; 522  :         case 'u':
; 523  :             base = 10;

	mov	DWORD PTR _base$1$[esp+64], 10		; 0000000aH

; 524  :             goto print_num;

	jmp	SHORT $print_num$101
$LN53@v_lprintf:

; 525  :             
; 526  :         case 'o':
; 527  :             base = 8;
; 528  :             if (flag & F_HASH) 

	test	bl, 4
	mov	DWORD PTR _base$1$[esp+64], 8
	mov	eax, OFFSET ??_C@_01GBGANLPD@0@
	cmove	eax, DWORD PTR _prefix$1$[esp+64]
$LN97@v_lprintf:

; 529  :                 prefix = "0";
; 530  : print_num:
; 531  :             if (opt_long > 0) {

	mov	DWORD PTR _prefix$1$[esp+64], eax
$print_num$101:
	mov	edx, DWORD PTR _arg_ptr$1$[esp+64]
	test	ecx, ecx
	jle	SHORT $LN55@v_lprintf

; 532  :                 if (opt_long > 1)

	cmp	ecx, 1
	jle	SHORT $LN55@v_lprintf

; 533  :                     num = va_arg(arg_ptr, __int64);

	mov	eax, DWORD PTR [edx]
	add	edx, 8
	mov	DWORD PTR _arg_ptr$1$[esp+64], edx
	mov	edx, DWORD PTR [edx-4]
	jmp	SHORT $LN98@v_lprintf
$LN55@v_lprintf:

; 534  :                 else
; 535  :                     num = (__int64)va_arg(arg_ptr, long);
; 536  :             } else 
; 537  :                 num = (__int64)va_arg(arg_ptr, int);
; 538  : 
; 539  :             len += output_integer(num, opt_long, ch, 

	mov	eax, DWORD PTR [edx]
	add	edx, 4
	mov	DWORD PTR _arg_ptr$1$[esp+64], edx
	cdq
$LN98@v_lprintf:
	push	DWORD PTR _pad$[esp+64]
	mov	DWORD PTR _num$1$[esp+68], eax
	push	DWORD PTR _prefix$1$[esp+68]
	mov	eax, DWORD PTR _precision$1$[esp+72]
	push	DWORD PTR _base$1$[esp+72]
	push	ebx
	push	eax
	push	edi
	push	edx
	push	DWORD PTR _num$1$[esp+92]
	mov	dl, BYTE PTR _ch$1$[esp+96]
	call	_output_integer
	mov	ebx, DWORD PTR _len$1$[esp+96]
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _len$1$[esp+64], ebx

; 540  :                 width, precision, flag, base, prefix, pad);
; 541  :             break;

	jmp	$LN65@v_lprintf
$LN59@v_lprintf:

; 542  :   
; 543  :         /* print a floating point value */
; 544  :         case 'g':
; 545  :         case 'F':  
; 546  :         case 'f':
; 547  :         case 'e':
; 548  :         case 'E':
; 549  :             len += output_double(va_arg(arg_ptr, double), ch, 

	mov	edx, DWORD PTR _arg_ptr$1$[esp+64]
	sub	esp, 8
	mov	eax, DWORD PTR tv497[esp+72]
	add	edx, 8
	mov	cl, BYTE PTR _ch$1$[esp+72]
	movsx	eax, al
	mov	DWORD PTR _arg_ptr$1$[esp+72], edx
	movsd	xmm0, QWORD PTR [edx-8]
	mov	edx, edi
	movsd	QWORD PTR [esp], xmm0
	push	eax
	mov	eax, DWORD PTR _precision$1$[esp+76]
	push	ebx
	push	eax
	call	_output_double
	mov	ebx, DWORD PTR _len$1$[esp+84]
	add	esp, 20					; 00000014H
	add	ebx, eax
	mov	DWORD PTR _len$1$[esp+64], ebx

; 550  :                 width, precision, flag, pad);
; 551  :             break;

	jmp	$LN65@v_lprintf
$LN64@v_lprintf:

; 552  : 
; 553  :         /* print a memory block */
; 554  :         case 'M': 
; 555  :             ptr = va_arg(arg_ptr, unsigned char *);

	mov	edx, DWORD PTR _arg_ptr$1$[esp+64]

; 556  :             len += output_memory_block(ptr, va_arg(arg_ptr, int), 

	mov	eax, DWORD PTR tv497[esp+64]
	movsx	eax, al
	push	eax
	mov	ecx, DWORD PTR [edx]
	add	edx, 8
	mov	eax, DWORD PTR _precision$1$[esp+68]
	push	ebx
	push	eax
	mov	DWORD PTR _arg_ptr$1$[esp+76], edx
	mov	edx, DWORD PTR [edx-4]
	push	edi
	call	_output_memory_block
	mov	ebx, DWORD PTR _len$1$[esp+80]
	add	esp, 16					; 00000010H
	add	ebx, eax
	mov	DWORD PTR _len$1$[esp+64], ebx
	jmp	$LN65@v_lprintf
$LN83@v_lprintf:

; 565  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN92@v_lprintf:
	DD	$LN83@v_lprintf
	DD	$LN16@v_lprintf
	DD	$LN9@v_lprintf
	DD	$LN39@v_lprintf
	DD	$LN31@v_lprintf
	DD	$LN17@v_lprintf
	DD	$LN15@v_lprintf
	DD	$LN34@v_lprintf
	DD	$LN18@v_lprintf
	DD	$LN59@v_lprintf
	DD	$LN11@v_lprintf
	DD	$LN64@v_lprintf
	DD	$LN46@v_lprintf
	DD	$LN44@v_lprintf
	DD	$LN38@v_lprintf
	DD	$LN50@v_lprintf
	DD	$LN10@v_lprintf
	DD	$LN13@v_lprintf
	DD	$LN40@v_lprintf
	DD	$LN53@v_lprintf
	DD	$LN45@v_lprintf
	DD	$LN52@v_lprintf
	DD	$LN47@v_lprintf
	DD	$LN95@v_lprintf
$LN91@v_lprintf:
	DB	0
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	1
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	2
	DB	23					; 00000017H
	DB	3
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	4
	DB	5
	DB	23					; 00000017H
	DB	6
	DB	7
	DB	23					; 00000017H
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	9
	DB	9
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	12					; 0000000cH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	9
	DB	9
	DB	9
	DB	16					; 00000010H
	DB	15					; 0000000fH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	10					; 0000000aH
	DB	23					; 00000017H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	21					; 00000015H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	17					; 00000011H
___v_lprintf ENDP
_TEXT	ENDS
END
