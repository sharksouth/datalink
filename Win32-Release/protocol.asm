; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30142.1 

	TITLE	c:\users\sharksouth\onedrive - bupt.edu.cn\学习资料\计算机网络\课程实验\lab1-2022(win+linux)\lab1-windows-vs2019\win32-release\protocol.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ ; `string'
PUBLIC	??_C@_01FHEEJDEE@A@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B@				; `string'
PUBLIC	??_C@_03MAMPKPPK@XXX@				; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_06HMNHKJD@utopia@				; `string'
PUBLIC	??_C@_05ONANONLM@flood@				; `string'
PUBLIC	??_C@_04CMBNNLNM@ibib@				; `string'
PUBLIC	??_C@_05HPGGOJCM@nolog@				; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_04LPGMAPLE@port@				; `string'
PUBLIC	??_C@_03BMIBANNE@ber@				; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_03KAFGPDAP@ttl@				; `string'
PUBLIC	??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ ; `string'
PUBLIC	??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ ; `string'
PUBLIC	??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@	; `string'
PUBLIC	??_C@_03JODACOMD@nul@				; `string'
PUBLIC	??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@		; `string'
PUBLIC	??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ ; `string'
PUBLIC	??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ ; `string'
PUBLIC	??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@	; `string'
PUBLIC	??_C@_04JLMDILM@?4exe@				; `string'
PUBLIC	??_C@_06GOMLAJLH@?9A?4log@			; `string'
PUBLIC	??_C@_06OIFPHLBJ@?9B?4log@			; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ ; `string'
PUBLIC	??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0M@KDHDHOOB@May?512?52022@		; `string'
PUBLIC	??_C@_03EMGHBCAM@4?40@				; `string'
PUBLIC	??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ ; `string'
PUBLIC	??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ ; `string'
PUBLIC	??_C@_05KDIEGDNJ@?$CF?41E?6@			; `string'
PUBLIC	??_C@_02NODKCLPH@0?6@				; `string'
PUBLIC	??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ ; `string'
PUBLIC	??_C@_0BC@BNICANMP@Create?5TCP?5socket@		; `string'
PUBLIC	??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ ; `string'
PUBLIC	??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ ; `string'
PUBLIC	??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ ; `string'
PUBLIC	??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ ; `string'
PUBLIC	??_C@_06MJLDIBBJ@Done?4?6@			; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41@			; `string'
PUBLIC	??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ ; `string'
PUBLIC	??_C@_08OPNBKLNK@Failed?$CB?6@			; `string'
PUBLIC	??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ ; `string'
PUBLIC	??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@		; `string'
PUBLIC	??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ ; `string'
PUBLIC	??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@	; `string'
PUBLIC	??_C@_0BB@IAFLKGG@No?5enough?5memory@		; `string'
PUBLIC	??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@	; `string'
PUBLIC	??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ ; `string'
PUBLIC	??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ ; `string'
PUBLIC	??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ ; `string'
PUBLIC	??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ ; `string'
PUBLIC	??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@		; `string'
PUBLIC	??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ ; `string'
PUBLIC	??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ ; `string'
PUBLIC	??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ ; `string'
PUBLIC	??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ ; `string'
PUBLIC	??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@	; `string'
PUBLIC	??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ ; `string'
PUBLIC	??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ ; `string'
PUBLIC	??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ ; `string'
PUBLIC	??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_06EJNPPGH@Quit?4?6@			; `string'
PUBLIC	??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ ; `string'
EXTRN	__imp____WSAFDIsSet@8:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__accept@12:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__send@16:PROC
EXTRN	_rand:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	_tolower:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	_strtod:PROC
EXTRN	_fflush:PROC
EXTRN	_fopen:PROC
EXTRN	_srand:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__ftime64:PROC
EXTRN	_calloc:PROC
EXTRN	_asctime:PROC
EXTRN	__imp__setsockopt@20:PROC
EXTRN	_exit:PROC
;	COMDAT ??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
CONST	SEGMENT
??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ DB 'Memory used'
	DB	' by ''protocol.lib'' is corrupted by your program', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EJNPPGH@Quit?4?6@
CONST	SEGMENT
??_C@_06EJNPPGH@Quit?4?6@ DB 'Quit.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ DB '+'
	DB	'+++++ Sleep(%d)=%d+%d (cnt %d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@
CONST	SEGMENT
??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ DB '-'
	DB	'----- noSleep %d, sleep %d, Elapse %d ticks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@
CONST	SEGMENT
??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ DB '='
	DB	'===== CPU BUSY for %d ms (cnt %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
CONST	SEGMENT
??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ DB '** W'
	DB	'ARNING: System too busy, sleep %d ms, but be awakened %d ms l'
	DB	'ater', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
CONST	SEGMENT
??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@ DB 'system select()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
CONST	SEGMENT
??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ DB 'rec'
	DB	'v_frame(): %d-byte buffer is too small to save %d-byte receiv'
	DB	'ed frame', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
CONST	SEGMENT
??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ DB 'recv_fr'
	DB	'ame(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
CONST	SEGMENT
??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ DB '.'
	DB	'... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
CONST	SEGMENT
??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ DB 'Network Laye'
	DB	'r received a bad packet from data link layer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
CONST	SEGMENT
??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@ DB 'Bad Packet length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
CONST	SEGMENT
??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ DB 'get_pa'
	DB	'cket(): Network layer is not ready for a new packet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
CONST	SEGMENT
??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ DB 'start'
	DB	'_timer(): timer No. must be 0~128', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
CONST	SEGMENT
??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ DB 'recv_by'
	DB	'te(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
CONST	SEGMENT
??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ DB 'Impose nois'
	DB	'e on received data, %u/%u=%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@ DB 'TCP disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IAFLKGG@No?5enough?5memory@
CONST	SEGMENT
??_C@_0BB@IAFLKGG@No?5enough?5memory@ DB 'No enough memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@ DB 'TCP Disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
CONST	SEGMENT
??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ DB 'Physical Laye'
	DB	'r Sending Queue overflow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================='
	DB	'===', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
CONST	SEGMENT
??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@ DB 'New epoch: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
CONST	SEGMENT
??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ DB 'Station B fa'
	DB	'iled to connect station A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPNBKLNK@Failed?$CB?6@
CONST	SEGMENT
??_C@_08OPNBKLNK@Failed?$CB?6@ DB 'Failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
CONST	SEGMENT
??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ DB 'Station B is '
	DB	'connecting station A (TCP port %u) ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJLDIBBJ@Done?4?6@
CONST	SEGMENT
??_C@_06MJLDIBBJ@Done?4?6@ DB 'Done.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@
CONST	SEGMENT
??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ DB 'Station A fai'
	DB	'led to communicate with station B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
CONST	SEGMENT
??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ DB 'Station A is'
	DB	' waiting for station B on TCP port %u ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
CONST	SEGMENT
??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ DB 'Station A f'
	DB	'ailed to bind TCP port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
CONST	SEGMENT
??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ DB 'Station A:'
	DB	' Failed to bind TCP port %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BNICANMP@Create?5TCP?5socket@
CONST	SEGMENT
??_C@_0BC@BNICANMP@Create?5TCP?5socket@ DB 'Create TCP socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
CONST	SEGMENT
??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ DB 'L'
	DB	'og file "%s", TCP port %d, debug mask 0x%02x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NODKCLPH@0?6@
CONST	SEGMENT
??_C@_02NODKCLPH@0?6@ DB '0', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIEGDNJ@?$CF?41E?6@
CONST	SEGMENT
??_C@_05KDIEGDNJ@?$CF?41E?6@ DB '%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
CONST	SEGMENT
??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ DB 'Chan'
	DB	'nel: %d bps, %d ms propagation delay, bit error rate ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
CONST	SEGMENT
??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ DB 'Protocol'
	DB	'.lib, version %s, jiangyanjun0718@bupt.edu.cn', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHBCAM@4?40@
CONST	SEGMENT
??_C@_03EMGHBCAM@4?40@ DB '4.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KDHDHOOB@May?512?52022@
CONST	SEGMENT
??_C@_0M@KDHDHOOB@May?512?52022@ DB 'May 12 2022', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================', 0aH
	DB	'                    Station %s                               '
	DB	0aH, '--------------------------------------------------------'
	DB	'-----', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
CONST	SEGMENT
??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ DB 'WARNING: Fa'
	DB	'iled to create log file "%s": %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIFPHLBJ@?9B?4log@
CONST	SEGMENT
??_C@_06OIFPHLBJ@?9B?4log@ DB '-B.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOMLAJLH@?9A?4log@
CONST	SEGMENT
??_C@_06GOMLAJLH@?9A?4log@ DB '-A.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe@ DB '.exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
CONST	SEGMENT
??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@ DB 0aH, 'FATAL: %s', 0aH, 'A'
	DB	'bort.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
CONST	SEGMENT
??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ DB 'Station'
	DB	' name must be ''A'' or ''B''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
CONST	SEGMENT
??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ DB 'ERROR: Unsupported'
	DB	' option', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
CONST	SEGMENT
??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@ DB 'Bad BER %.3f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JODACOMD@nul@
CONST	SEGMENT
??_C@_03JODACOMD@nul@ DB 'nul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
CONST	SEGMENT
??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@ DB '?ufind:p:b:l:t:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
CONST	SEGMENT
??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ DB 0aH
	DB	'Options : ', 0aH, '    -?, --help : print this', 0aH, '    -u'
	DB	', --utopia : utopia channel (an error-free channel)', 0aH, ' '
	DB	'   -f, --flood : flood traffic', 0aH, '    -i, --ibib  : set '
	DB	'station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...', 0aH
	DB	'    -n, --nolog : do not create log file', 0aH, '    -d, --de'
	DB	'bug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)', 0aH
	DB	'    -p, --port=<port#> : TCP port number (default: %u)', 0aH, ' '
	DB	'   -b, --ber=<ber> : Bit Error Rate (received data only)', 0aH
	DB	'    -l, --log=<filename> : using assigned file as log file', 0aH
	DB	'    -t, --ttl=<seconds> : set time-to-live', 0aH, 0aH, 'i.e.', 0aH
	DB	'    %s -fd3 -b 1e-4 A', 0aH, '    %s --flood --debug=3 --ber='
	DB	'1e-4 A', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
CONST	SEGMENT
??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ DB 0aH
	DB	'Usage:', 0aH, '  %s <options> <station-name>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KAFGPDAP@ttl@
CONST	SEGMENT
??_C@_03KAFGPDAP@ttl@ DB 'ttl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMIBANNE@ber@
CONST	SEGMENT
??_C@_03BMIBANNE@ber@ DB 'ber', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPGMAPLE@port@
CONST	SEGMENT
??_C@_04LPGMAPLE@port@ DB 'port', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPGGOJCM@nolog@
CONST	SEGMENT
??_C@_05HPGGOJCM@nolog@ DB 'nolog', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBNNLNM@ibib@
CONST	SEGMENT
??_C@_04CMBNNLNM@ibib@ DB 'ibib', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONANONLM@flood@
CONST	SEGMENT
??_C@_05ONANONLM@flood@ DB 'flood', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMNHKJD@utopia@
CONST	SEGMENT
??_C@_06HMNHKJD@utopia@ DB 'utopia', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAMPKPPK@XXX@
CONST	SEGMENT
??_C@_03MAMPKPPK@XXX@ DB 'XXX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B@
CONST	SEGMENT
??_C@_01HMGJMAIH@B@ DB 'B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01FHEEJDEE@A@
CONST	SEGMENT
??_C@_01FHEEJDEE@A@ DB 'A', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
CONST	SEGMENT
??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ DB 'Windows Socket DLL '
	DB	'Error', 0aH, 00H				; `string'
_mode_seed DD	098bcde1H
_mode_cycle DD	064H
_mode_tick DD	0fH
CONST	ENDS
PUBLIC	_dbg_warning
PUBLIC	_phl_sq_len
PUBLIC	_station_name
PUBLIC	_printf
PUBLIC	_get_ms
PUBLIC	_disable_network_layer
PUBLIC	_protocol_init
PUBLIC	_dbg_frame
PUBLIC	_send_frame
PUBLIC	_stop_ack_timer
PUBLIC	_recv_frame
PUBLIC	_enable_network_layer
PUBLIC	_start_timer
PUBLIC	_dbg_event
PUBLIC	_get_packet
PUBLIC	_wait_for_event
PUBLIC	_start_ack_timer
PUBLIC	_stop_timer
PUBLIC	_put_packet
_layer3_ready DD 01H DUP (?)
?last_warn@?BF@??wait_for_event@@9@9 DQ 01H DUP (?)	; `wait_for_event'::`21'::last_warn
_send_bytes_allowed DD 01H DUP (?)
_timer	DD	081H DUP (?)
_nbits	DD	01H DUP (?)
_rbytes	DD	01H DUP (?)
_station DD	01H DUP (?)
?pkt_no@?1??get_packet@@9@9 DD 01H DUP (?)		; `get_packet'::`2'::pkt_no
_sock	DD	01H DUP (?)
_rf_head DD	01H DUP (?)
_rblk_head DD	01H DUP (?)
?last_ts@?1??socket_send@@9@9 DD 01H DUP (?)		; `socket_send'::`2'::last_ts
_head_magic DD	020H DUP (?)
_rf_buf	DD	01H DUP (?)
_rblk_tail DD	01H DUP (?)
_mode_ibib DD	01H DUP (?)
_rf_tail DD	01H DUP (?)
_foot_magic DD	020H DUP (?)
_sq_head DD	01H DUP (?)
_noise	DD	01H DUP (?)
_debug_mask DD	01H DUP (?)
?last_ts@?1??put_packet@@9@9 DD 01H DUP (?)		; `put_packet'::`2'::last_ts
_sq_tail DD	01H DUP (?)
_sq	DB	020000H DUP (?)
_network_layer_active DD 01H DUP (?)
_now	DD	01H DUP (?)
?last_ts@?1??network_layer_ready@@9@9 DD 01H DUP (?)	; `network_layer_ready'::`2'::last_ts
_ts0	DD	01H DUP (?)
_rpackets DD	01H DUP (?)
_mode_flood DD	01H DUP (?)
	ALIGN	8

_epoch	DQ	01H DUP (?)
_BSS	ENDS
_intopts DD	FLAT:??_C@_04PCJFHION@help@
	DD	00H
	DD	00H
	DD	03fH
	DD	FLAT:??_C@_06HMNHKJD@utopia@
	DD	00H
	DD	00H
	DD	075H
	DD	FLAT:??_C@_05ONANONLM@flood@
	DD	00H
	DD	00H
	DD	066H
	DD	FLAT:??_C@_04CMBNNLNM@ibib@
	DD	00H
	DD	00H
	DD	069H
	DD	FLAT:??_C@_05HPGGOJCM@nolog@
	DD	00H
	DD	00H
	DD	06eH
	DD	FLAT:??_C@_05GFCDIDHO@debug@
	DD	01H
	DD	00H
	DD	064H
	DD	FLAT:??_C@_04LPGMAPLE@port@
	DD	01H
	DD	00H
	DD	070H
	DD	FLAT:??_C@_03BMIBANNE@ber@
	DD	01H
	DD	00H
	DD	062H
	DD	FLAT:??_C@_03MGHMBJCF@log@
	DD	01H
	DD	00H
	DD	06cH
	DD	FLAT:??_C@_03KAFGPDAP@ttl@
	DD	01H
	DD	00H
	DD	074H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_port	DW	0e708H
	ORG $+2
_mode_life DD	07fffff00H
?holdrand@?1??randA@@9@9 DD 065109bc4H			; `randA'::`2'::holdrand
_inform_phl_ready DD 01H
_ber	DQ	03ee4f8b588e368f1r		; 1e-05
?holdrand@?1??randB@@9@9 DD 01e459090H			; `randB'::`2'::holdrand
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _put_packet
_TEXT	SEGMENT
_put_packet PROC					; COMDAT
; _packet$ = ecx
; _len$ = edx

; 659  :     static int last_ts = 0;
; 660  :     int i, (*my_rand)(void) = station == 'a' ? randB : randA;

	cmp	DWORD PTR _station, 97			; 00000061H
	mov	eax, OFFSET _randB
	push	ebx
	push	esi
	push	edi
	mov	edi, OFFSET _randA
	mov	ebx, ecx
	cmove	edi, eax

; 661  : 
; 662  :     if (len != PKT_LEN) 

	cmp	edx, 256				; 00000100H
	jne	$LN23@put_packet

; 664  : 
; 665  :     for (i = 2; i < PKT_LEN; i++) {

	mov	esi, 2
	npad	6
$LL7@put_packet:

; 666  :         if (packet[i] != next_char()) 

	call	edi
	cmp	BYTE PTR [esi+ebx], al
	jne	$LN17@put_packet

; 664  : 
; 665  :     for (i = 2; i < PKT_LEN; i++) {

	inc	esi
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL7@put_packet

; 668  :     }
; 669  :     rpackets++;
; 670  :     rbytes += len;
; 671  : 
; 672  :     if (now - last_ts > 2000 && now > ts0 + 2000) {

	mov	ecx, DWORD PTR _now
	mov	eax, ecx
	mov	edx, DWORD PTR _rpackets
	mov	edi, DWORD PTR _rbytes
	inc	edx
	sub	eax, DWORD PTR ?last_ts@?1??put_packet@@9@9
	add	edi, 256				; 00000100H
	mov	DWORD PTR _rpackets, edx
	mov	DWORD PTR _rbytes, edi
	cmp	eax, 2000				; 000007d0H
	jle	$LN13@put_packet
	mov	esi, DWORD PTR _ts0
	lea	eax, DWORD PTR [esi+2000]
	cmp	ecx, eax
	jle	$LN13@put_packet

; 673  :         double bps;
; 674  :         bps = (double)rbytes * 8 * 1000 / (now - ts0);

	movd	xmm2, edi
	sub	ecx, esi
	cvtdq2pd xmm2, xmm2

; 675  :         lprintf(".... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)\n", 

	mov	eax, DWORD PTR _nbits
	sub	esp, 8
	movd	xmm0, ecx
	mulsd	xmm2, QWORD PTR __real@4020000000000000
	mov	ecx, DWORD PTR _noise
	cvtdq2pd xmm0, xmm0
	mulsd	xmm2, QWORD PTR __real@408f400000000000
	movd	xmm1, ecx
	cvtdq2pd xmm1, xmm1
	divsd	xmm2, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm1, xmm0
	movaps	xmm0, xmm2
	divsd	xmm0, QWORD PTR __real@40bf400000000000
	movsd	QWORD PTR [esp], xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	push	ecx
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm0
	movsd	QWORD PTR [esp], xmm2
	push	edx
	push	OFFSET ??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
	call	_lprintf

; 676  :             rpackets, bps, bps / CHAN_BPS * 100, noise, (double)noise/nbits);
; 677  :         last_ts = now;

	mov	eax, DWORD PTR _now
	add	esp, 36					; 00000024H
	mov	DWORD PTR ?last_ts@?1??put_packet@@9@9, eax
$LN13@put_packet:

; 678  :     }
; 679  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN17@put_packet:

; 667  :             ABORT("Network Layer received a bad packet from data link layer");

	push	OFFSET ??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN23@put_packet:

; 663  :         ABORT("Bad Packet length");

	push	OFFSET ??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN21@put_packet:
	int	3
_put_packet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _stop_timer
_TEXT	SEGMENT
_stop_timer PROC					; COMDAT
; _nr$ = ecx

; 542  :     if (nr < ACK_TIMER_ID) 

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN2@stop_timer

; 543  :         timer[nr] = 0;

	mov	DWORD PTR _timer[ecx*4], 0
$LN2@stop_timer:

; 544  : }

	ret	0
_stop_timer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _start_ack_timer
_TEXT	SEGMENT
_start_ack_timer PROC					; COMDAT
; _ms$dead$ = ecx

; 555  :     if (timer[ACK_TIMER_ID] == 0)

	cmp	DWORD PTR _timer+512, 0
	jne	SHORT $LN2@start_ack_

; 556  :         timer[ACK_TIMER_ID] = now + ms;

	mov	eax, DWORD PTR _now
	add	eax, 300				; 0000012cH
	mov	DWORD PTR _timer+512, eax
$LN2@start_ack_:

; 557  : }

	ret	0
_start_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _wait_for_event
_TEXT	SEGMENT
_rfd$ = -544						; size = 260
_wfd$ = -280						; size = 260
_tm$ = -12						; size = 8
_arg$1$ = -4						; size = 4
_wait_for_event PROC					; COMDAT
; _arg$ = ecx

; 762  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
	push	ebx
	mov	ebx, DWORD PTR __imp____WSAFDIsSet@8
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _arg$1$[ebp], edi
$LL2@wait_for_e:

; 763  :     fd_set rfd, wfd;
; 764  :     struct timeval tm;
; 765  :     int event, n, i, nfds;
; 766  :     unsigned char ch;
; 767  : 
; 768  :     for (;;) {
; 769  : 
; 770  :         now = get_ms();

	call	_get_ms
	mov	esi, eax

; 771  :      
; 772  :         /* commit received socket data */
; 773  :         if (rblk_head && rblk_head->commit_ts <= now) {

	mov	eax, DWORD PTR _rblk_head
	mov	DWORD PTR _now, esi
	test	eax, eax
	je	$LN30@wait_for_e
	cmp	DWORD PTR [eax], esi
	jg	$LN30@wait_for_e

; 774  :             n = rblk_head->wptr - rblk_head->rptr;

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]

; 775  :             
; 776  :             if (ts0 == 0) {

	cmp	DWORD PTR _ts0, 0
	jne	SHORT $LN19@wait_for_e

; 777  :                 ts0 = now;
; 778  :                 if (ts0 >= n / 2)

	mov	eax, edi
	mov	DWORD PTR _ts0, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jl	SHORT $LN19@wait_for_e

; 779  :                     ts0 -= n / 2;

	sub	esi, eax
	mov	DWORD PTR _ts0, esi
$LN19@wait_for_e:

; 780  :             }
; 781  : 
; 782  :             for (i = 0; i < n; i++) {

	test	edi, edi
	jle	$LN70@wait_for_e
	npad	7
$LL7@wait_for_e:

; 783  :                 ch = recv_byte();

	call	_recv_byte
	mov	dl, al

; 784  :                 if (ch == 0xff) {

	cmp	dl, 255					; 000000ffH
	jne	SHORT $LN20@wait_for_e

; 785  :                     if (rf_buf == NULL) 

	mov	ecx, DWORD PTR _rf_buf
	test	ecx, ecx
	jne	SHORT $LN22@wait_for_e

; 786  :                         rf_buf = (struct RCV_FRAME *)calloc(1, sizeof(struct RCV_FRAME));

	push	2060					; 0000080cH
	push	1
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _rf_buf, eax
	jmp	SHORT $LN5@wait_for_e
$LN22@wait_for_e:

; 787  :                     else {
; 788  :                         if (rf_buf->len > 0) {

	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN5@wait_for_e

; 789  :                             if (rf_head == NULL) 

	cmp	DWORD PTR _rf_head, 0
	jne	SHORT $LN25@wait_for_e

; 790  :                                 rf_head = rf_tail = rf_buf;

	mov	DWORD PTR _rf_head, ecx
	jmp	SHORT $LN72@wait_for_e
$LN25@wait_for_e:

; 791  :                             else {
; 792  :                                 rf_tail->link = rf_buf;

	mov	eax, DWORD PTR _rf_tail
	mov	DWORD PTR [eax+2056], ecx
$LN72@wait_for_e:

; 793  :                                 rf_tail = rf_buf;
; 794  :                             }
; 795  :                             rf_buf = NULL;

	mov	DWORD PTR _rf_tail, ecx
	mov	DWORD PTR _rf_buf, 0

; 796  :                         }
; 797  :                     }

	jmp	SHORT $LN5@wait_for_e
$LN20@wait_for_e:

; 798  :                 } else if (rf_buf && rf_buf->len < sizeof(rf_buf->frame)) {

	mov	eax, DWORD PTR _rf_buf
	test	eax, eax
	je	SHORT $LN5@wait_for_e
	mov	esi, DWORD PTR [eax]
	cmp	esi, 2048				; 00000800H
	jae	SHORT $LN5@wait_for_e

; 799  :                     if (rf_buf->state == 0) {

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN28@wait_for_e

; 800  :                         rf_buf->frame[rf_buf->len] = ch;

	mov	BYTE PTR [esi+eax+8], dl

; 801  :                         rf_buf->state = 1;

	mov	DWORD PTR [eax+4], 1

; 802  :                     } else {

	jmp	SHORT $LN5@wait_for_e
$LN28@wait_for_e:

; 803  :                         rf_buf->frame[rf_buf->len] |= (ch << 4) ^ (ch & 0xf0);

	mov	cl, dl
	shl	dl, 4
	and	cl, 240					; 000000f0H
	xor	cl, dl
	or	BYTE PTR [esi+eax+8], cl

; 804  :                         rf_buf->len++;

	inc	DWORD PTR [eax]

; 805  :                         rf_buf->state = 0;

	mov	DWORD PTR [eax+4], 0
$LN5@wait_for_e:

; 780  :             }
; 781  : 
; 782  :             for (i = 0; i < n; i++) {

	sub	edi, 1
	jne	$LL7@wait_for_e
$LN70@wait_for_e:

; 806  :                     }
; 807  :                 }
; 808  :             }
; 809  : 
; 810  :             if (rf_head)

	cmp	DWORD PTR _rf_head, 0
	jne	$LN57@wait_for_e
	mov	edi, DWORD PTR _arg$1$[ebp]
$LN30@wait_for_e:

; 812  :         }
; 813  :         
; 814  :         /* test socket send/receive */
; 815  :         tm.tv_sec = tm.tv_usec = 0;
; 816  :         FD_ZERO(&rfd);
; 817  :         FD_ZERO(&wfd);
; 818  :         FD_SET(sock, &rfd);

	mov	eax, DWORD PTR _sock

; 819  :         FD_SET(sock, &wfd);
; 820  : 
; 821  :         nfds = (int)(sock + 1);
; 822  :         if (select(nfds, &rfd, &wfd, 0, &tm) < 0) 

	lea	ecx, DWORD PTR _tm$[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR _wfd$[ebp]
	mov	DWORD PTR _rfd$[ebp+4], eax
	push	ecx
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	DWORD PTR _wfd$[ebp+4], eax
	inc	eax
	mov	DWORD PTR _tm$[ebp+4], 0
	push	ecx
	push	eax
	mov	DWORD PTR _tm$[ebp], 0
	mov	DWORD PTR _rfd$[ebp], 1
	mov	DWORD PTR _wfd$[ebp], 1
	call	DWORD PTR __imp__select@20
	test	eax, eax
	js	$LN58@wait_for_e

; 824  :          
; 825  :         /* socket send */
; 826  :         if (FD_ISSET(sock, &wfd)) 

	lea	eax, DWORD PTR _wfd$[ebp]
	push	eax
	push	DWORD PTR _sock
	call	ebx
	test	eax, eax
	je	SHORT $LN34@wait_for_e

; 827  :             socket_send();

	call	_socket_send
$LN34@wait_for_e:

; 828  : 
; 829  :         /* socket receive */
; 830  :         if (FD_ISSET(sock, &rfd)) 

	lea	eax, DWORD PTR _rfd$[ebp]
	push	eax
	push	DWORD PTR _sock
	call	ebx
	test	eax, eax
	je	SHORT $LN35@wait_for_e

; 831  :             socket_recv();

	call	_socket_recv
$LN35@wait_for_e:

; 832  : 
; 833  :         /* network layer event */
; 834  :         if (network_layer_ready()) {

	call	_network_layer_ready
	test	eax, eax
	jne	$LN59@wait_for_e

; 835  :             layer3_ready = 1;
; 836  :             return NETWORK_LAYER_READY;
; 837  :         }
; 838  : 
; 839  :         /* check all timers */
; 840  :         if ((event = scan_timer(arg)) != 0)

	mov	ecx, edi
	call	_scan_timer
	test	eax, eax
	jne	$LN3@wait_for_e

; 841  :             return event;
; 842  : 
; 843  :         /* physical layer event */
; 844  :         if (inform_phl_ready && phl_sq_len()  < PHL_SQ_LEVEL) {

	cmp	DWORD PTR _inform_phl_ready, eax
	je	SHORT $LN38@wait_for_e
	call	_phl_sq_len
	cmp	eax, 50					; 00000032H
	jl	$LN61@wait_for_e
$LN38@wait_for_e:

; 847  :         }
; 848  : 
; 849  :         /* delay 'mode_tick' ms */
; 850  :         if (1) {
; 851  :             int ms0, t;
; 852  :             static time_t last_warn;
; 853  :             ms0 = get_ms();

	call	_get_ms
	mov	esi, eax

; 854  :             magic_check();

	call	_magic_check

; 855  :             Sleep(mode_tick);

	push	15					; 0000000fH
	call	DWORD PTR __imp__Sleep@4

; 856  :             t = get_ms() - ms0;

	call	_get_ms
	mov	edi, eax
	sub	edi, esi

; 857  :             if (t > mode_tick + 50 && time(0) > last_warn + 1) {

	cmp	edi, 65					; 00000041H
	jle	SHORT $LN41@wait_for_e
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

	push	0
	call	__time64
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c

; 857  :             if (t > mode_tick + 50 && time(0) > last_warn + 1) {

	mov	esi, DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

	add	esp, 4
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c

; 857  :             if (t > mode_tick + 50 && time(0) > last_warn + 1) {

	mov	ecx, DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9+4
	add	esi, 1
	adc	ecx, 0
	cmp	edx, ecx
	jl	SHORT $LN41@wait_for_e
	jg	SHORT $LN68@wait_for_e
	cmp	eax, esi
	jbe	SHORT $LN41@wait_for_e
$LN68@wait_for_e:

; 858  :                 lprintf("** WARNING: System too busy, sleep %d ms, but be awakened %d ms later\n", 

	push	edi
	push	15					; 0000000fH
	push	OFFSET ??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
	call	_lprintf
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

	push	0
	call	__time64
	add	esp, 4
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c

; 860  :                 last_warn = time(0);

	mov	DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9, eax
	mov	DWORD PTR ?last_warn@?BF@??wait_for_event@@9@9+4, edx
$LN41@wait_for_e:

; 861  :             }
; 862  :         } else {
; 863  :             int ticks, ms;
; 864  : 
; 865  :             sleep_cnt++;
; 866  : 
; 867  :             ms = get_ms();
; 868  :             if (start_ms == 0)
; 869  :                 start_ms = ms;
; 870  :             else if (ms - wakeup_ms > 1) {
; 871  :                 ticks = (ms - start_ms) / mode_tick;
; 872  :                 lprintf("====== CPU BUSY for %d ms (cnt %d)\n", ms - wakeup_ms, ++busy_cnt);
; 873  :                 lprintf("------ noSleep %d, sleep %d, Elapse %d ticks\n", ticks - sleep_cnt, sleep_cnt, ticks);
; 874  :             }
; 875  : 
; 876  :             magic_check();
; 877  :             ms = get_ms();
; 878  :             Sleep(mode_tick);
; 879  :             wakeup_ms = get_ms();
; 880  : 
; 881  :             ms = wakeup_ms - ms;
; 882  :             if (ms > mode_tick + 1 || ms < mode_tick - 1) 
; 883  :                 lprintf("++++++ Sleep(%d)=%d+%d (cnt %d)\n", mode_tick, mode_tick, ms - mode_tick, ++bias_cnt);
; 884  :         }
; 885  : 
; 886  :         if (now > mode_life) {

	mov	eax, DWORD PTR _now
	cmp	eax, DWORD PTR _mode_life
	jg	SHORT $LN62@wait_for_e

; 889  :         }
; 890  :     }

	mov	edi, DWORD PTR _arg$1$[ebp]
	jmp	$LL2@wait_for_e
$LN57@wait_for_e:

; 811  :                 return FRAME_RECEIVED;

	mov	eax, 2
$LN3@wait_for_e:

; 891  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@wait_for_e:

; 845  :             inform_phl_ready = 0;

	mov	DWORD PTR _inform_phl_ready, 0

; 846  :             return PHYSICAL_LAYER_READY;

	mov	eax, 1

; 891  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@wait_for_e:
	pop	edi
	pop	esi
	mov	DWORD PTR _layer3_ready, 1
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@wait_for_e:

; 823  :             ABORT("system select()");

	push	OFFSET ??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN62@wait_for_e:

; 887  :             lprintf("Quit.\n");

	push	OFFSET ??_C@_06EJNPPGH@Quit?4?6@
	call	_lprintf
	add	esp, 4

; 888  :             exit(0);

	push	0
	call	_exit
$LN71@wait_for_e:
	int	3
_wait_for_event ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _get_packet
_TEXT	SEGMENT
_get_packet PROC					; COMDAT
; _packet$ = ecx

; 638  :     static int pkt_no = 0;
; 639  :     int i, len;
; 640  :     int (*my_rand)(void) = station == 'a' ? randA : randB;

	cmp	DWORD PTR _station, 97			; 00000061H
	mov	eax, OFFSET _randA
	push	ebx
	push	esi
	push	edi
	mov	edi, OFFSET _randB
	mov	ebx, ecx
	cmove	edi, eax

; 641  : 
; 642  :     if (!layer3_ready)

	cmp	DWORD PTR _layer3_ready, 0
	je	SHORT $LN16@get_packet

; 644  :     
; 645  :     len = PKT_LEN;

	mov	esi, 2
$LL7@get_packet:

; 646  :     for (i = 2; i < len; i++)
; 647  :         packet[i] = next_char();

	call	edi
	mov	BYTE PTR [esi+ebx], al
	inc	esi
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL7@get_packet

; 648  :     *(unsigned short *)packet = (station - 'a' + 1) * 10000 + (pkt_no++ % 10000);

	mov	esi, DWORD PTR ?pkt_no@?1??get_packet@@9@9
	mov	eax, 1759218605				; 68db8badH
	imul	esi
	mov	eax, DWORD PTR _station
	sar	edx, 12					; 0000000cH
	mov	ecx, edx

; 649  : 
; 650  :     layer3_ready = 0;

	mov	DWORD PTR _layer3_ready, 0
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	sub	eax, ecx
	imul	eax, eax, 10000

; 651  : 
; 652  :     return len;
; 653  : }

	pop	edi
	add	eax, 23040				; 00005a00H
	add	eax, esi
	mov	WORD PTR [ebx], ax
	lea	eax, DWORD PTR [esi+1]
	pop	esi
	mov	DWORD PTR ?pkt_no@?1??get_packet@@9@9, eax
	mov	eax, 256				; 00000100H
	pop	ebx
	ret	0
$LN16@get_packet:

; 643  :         ABORT("get_packet(): Network layer is not ready for a new packet");

	push	OFFSET ??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN14@get_packet:
	int	3
_get_packet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _dbg_event
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_dbg_event PROC						; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp

; 687  : 	va_list arg_ptr;
; 688  : 
; 689  : 	if (debug_mask & DBG_FRAME) {

	test	BYTE PTR _debug_mask, 2
	je	SHORT $LN2@dbg_event

; 690  : 		va_start(arg_ptr, fmt);
; 691  : 		__v_lprintf(fmt, arg_ptr);

	mov	ecx, DWORD PTR _fmt$[ebp]
	lea	edx, DWORD PTR _fmt$[ebp+4]

; 692  : 		va_end(arg_ptr);
; 693  : 	}
; 694  : }

	pop	ebp

; 690  : 		va_start(arg_ptr, fmt);
; 691  : 		__v_lprintf(fmt, arg_ptr);

	jmp	___v_lprintf
$LN2@dbg_event:

; 692  : 		va_end(arg_ptr);
; 693  : 	}
; 694  : }

	pop	ebp
	ret	0
_dbg_event ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _start_timer
_TEXT	SEGMENT
_start_timer PROC					; COMDAT
; _nr$ = ecx
; _ms$dead$ = edx

; 534  : {

	mov	edx, ecx
	push	ecx

; 535  :     if (nr >= ACK_TIMER_ID) 

	cmp	edx, 128				; 00000080H
	jae	SHORT $LN9@start_time

; 537  :     timer[nr] = now + phl_sq_len() * 8000 / CHAN_BPS + ms;

	call	_phl_sq_len
	mov	ecx, DWORD PTR _now
	add	ecx, 2000				; 000007d0H
	add	eax, ecx
	mov	DWORD PTR _timer[edx*4], eax

; 538  : }

	pop	ecx
	ret	0
$LN9@start_time:

; 536  :         ABORT("start_timer(): timer No. must be 0~128");

	push	OFFSET ??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN7@start_time:
	int	3
_start_timer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _enable_network_layer
_TEXT	SEGMENT
_enable_network_layer PROC				; COMDAT

; 585  :     network_layer_active = 1;

	mov	DWORD PTR _network_layer_active, 1

; 586  : }

	ret	0
_enable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _recv_frame
_TEXT	SEGMENT
_msg$ = -256						; size = 256
_recv_frame PROC					; COMDAT
; _buf$ = ecx
; _size$dead$ = edx

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi

; 736  :     int len;
; 737  :     struct RCV_FRAME *next;
; 738  :     char msg[256];
; 739  : 
; 740  :     if (rf_head == NULL) 

	mov	edi, DWORD PTR _rf_head
	test	edi, edi
	je	SHORT $LN14@recv_frame

; 742  : 
; 743  :     len = rf_head->len;

	mov	ebx, DWORD PTR [edi]

; 744  : 
; 745  :     if (size < len) { 

	push	ebx
	cmp	ebx, 264				; 00000108H
	jg	SHORT $LN15@recv_frame

; 748  :     }
; 749  :     
; 750  :     memcpy(buf, rf_head->frame, len);

	lea	eax, DWORD PTR [edi+8]
	push	eax
	push	ecx
	call	_memcpy

; 751  : 
; 752  :     next = rf_head->link;

	mov	esi, DWORD PTR [edi+2056]

; 753  :     if (next == NULL) 

	xor	eax, eax
	mov	ecx, DWORD PTR _rf_tail
	add	esp, 12					; 0000000cH
	test	esi, esi
	cmove	ecx, eax

; 754  :         rf_tail = NULL;
; 755  :     free(rf_head); 

	push	edi
	mov	DWORD PTR _rf_tail, ecx
	call	_free
	add	esp, 4

; 756  :     rf_head = next;

	mov	DWORD PTR _rf_head, esi

; 757  : 
; 758  :     return len;

	mov	eax, ebx

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@recv_frame:

; 741  :         ABORT("recv_frame(): Receiving Queue is empty");

	push	OFFSET ??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN15@recv_frame:

; 746  :         sprintf(msg, "recv_frame(): %d-byte buffer is too small to save %d-byte received frame", size, len);

	push	264					; 00000108H
	lea	eax, DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
	push	eax
	call	_sprintf

; 747  :         ABORT(msg);

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 24					; 00000018H
	push	0
	call	_exit
$LN12@recv_frame:
	int	3
_recv_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _stop_ack_timer
_TEXT	SEGMENT
_stop_ack_timer PROC					; COMDAT

; 561  :     timer[ACK_TIMER_ID] = 0;

	mov	DWORD PTR _timer+512, 0

; 562  : }

	ret	0
_stop_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _send_frame
_TEXT	SEGMENT
_send_frame PROC					; COMDAT
; _frame$ = ecx
; _len$ = edx

; 392  : {

	push	ebx
	push	esi
	mov	ebx, ecx

; 393  :     int i;
; 394  : 
; 395  :     send_byte(0xff);

	or	cl, 255					; 000000ffH
	push	edi
	mov	edi, edx
	call	_send_byte
	xor	esi, esi

; 396  :     
; 397  :     for (i = 0; i < len; i++) {

	test	edi, edi
	jle	SHORT $LN3@send_frame
$LL4@send_frame:

; 398  :         send_byte(frame[i] & 0x0f);

	mov	cl, BYTE PTR [esi+ebx]
	and	cl, 15					; 0000000fH
	call	_send_byte

; 399  :         send_byte((frame[i] & 0xf0) >> 4);

	mov	cl, BYTE PTR [esi+ebx]
	shr	cl, 4
	call	_send_byte
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@send_frame
$LN3@send_frame:

; 400  :     }
; 401  :     send_byte(0xff);

	or	cl, 255					; 000000ffH

; 402  : }

	pop	edi
	pop	esi
	pop	ebx

; 400  :     }
; 401  :     send_byte(0xff);

	jmp	_send_byte
_send_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _dbg_frame
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_dbg_frame PROC						; COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp

; 698  : 	va_list arg_ptr;
; 699  : 
; 700  : 	if (debug_mask & DBG_FRAME) {

	test	BYTE PTR _debug_mask, 2
	je	SHORT $LN2@dbg_frame

; 701  : 		va_start(arg_ptr, fmt);
; 702  : 		__v_lprintf(fmt, arg_ptr);

	mov	ecx, DWORD PTR _fmt$[ebp]
	lea	edx, DWORD PTR _fmt$[ebp+4]

; 703  : 		va_end(arg_ptr);
; 704  : 	}
; 705  : }

	pop	ebp

; 701  : 		va_start(arg_ptr, fmt);
; 702  : 		__v_lprintf(fmt, arg_ptr);

	jmp	___v_lprintf
$LN2@dbg_frame:

; 703  : 		va_end(arg_ptr);
; 704  : 	}
; 705  : }

	pop	ebp
	ret	0
_dbg_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _protocol_init
_TEXT	SEGMENT
_name$ = -28						; size = 16
_on$1 = -12						; size = 4
_buf_size$2 = -8					; size = 4
_timeout_ms$3 = -4					; size = 4
_protocol_init PROC					; COMDAT
; _argc$ = ecx
; _argv$ = edx

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 256  : 	SOCKET admin_sock;
; 257  : 	int i;
; 258  :     struct sockaddr_in name;
; 259  : 
; 260  : 	socket_init();

	call	_socket_init

; 261  : 	magic_init();

	call	_magic_init

; 262  : 
; 263  : 	config(argc, argv);

	mov	edx, esi
	mov	ecx, edi
	call	_config

; 264  :   
; 265  :     if (station == 'a') {

	mov	eax, DWORD PTR _station
	mov	esi, 2
	mov	edi, DWORD PTR __imp__htons@4
	mov	ebx, DWORD PTR __imp__socket@12
	cmp	eax, 97					; 00000061H
	jne	$LN20@protocol_i

; 266  : 
; 267  :         srand(mode_seed ^ 97209);

	push	160085592				; 098ab658H
	call	_srand

; 268  : 
; 269  :         name.sin_family = AF_INET;
; 270  :         name.sin_addr.s_addr = INADDR_ANY;
; 271  :         name.sin_port = htons(port);

	movzx	eax, WORD PTR _port
	add	esp, 4
	mov	WORD PTR _name$[ebp], si
	mov	DWORD PTR _name$[ebp+4], 0
	push	eax
	call	edi

; 272  : 
; 273  :         admin_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	esi
	mov	WORD PTR _name$[ebp+2], ax
	call	ebx
	mov	esi, eax

; 274  :         if (admin_sock < 0) 
; 275  :             ABORT("Create TCP socket");
; 276  :         if (bind(admin_sock, (struct sockaddr *)&name, sizeof(name)) < 0) {

	lea	eax, DWORD PTR _name$[ebp]
	push	16					; 00000010H
	push	eax
	push	esi
	call	DWORD PTR __imp__bind@12
	test	eax, eax
	js	$LN40@protocol_i

; 279  :         }
; 280  : 
; 281  :         listen(admin_sock, 5);

	push	5
	push	esi
	call	DWORD PTR __imp__listen@8

; 282  : 
; 283  :         lprintf("Station A is waiting for station B on TCP port %u ... ", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
	call	_lprintf

; 284  :         fflush(stdout);

	push	1
	call	___acrt_iob_func
	add	esp, 12					; 0000000cH
	push	eax
	call	_fflush
	add	esp, 4

; 285  : 
; 286  :         sock = accept(admin_sock, 0, 0);

	push	0
	push	0
	push	esi
	call	DWORD PTR __imp__accept@12

; 287  :         if (sock < 0) 
; 288  :             ABORT("Station A failed to communicate with station B");
; 289  :         lprintf("Done.\n");

	push	OFFSET ??_C@_06MJLDIBBJ@Done?4?6@
	mov	DWORD PTR _sock, eax
	call	_lprintf
	add	esp, 4

; 290  : 
; 291  :         recv(sock, (char *)&epoch, sizeof(epoch), 0);

	push	0
	push	8
	push	OFFSET _epoch
	push	DWORD PTR _sock
	call	DWORD PTR __imp__recv@16
	mov	eax, DWORD PTR _station
	mov	esi, 2
$LN20@protocol_i:

; 292  :     }
; 293  : 
; 294  :     if (station == 'b') {

	cmp	eax, 98					; 00000062H
	jne	$LN24@protocol_i

; 295  : 
; 296  :         srand(mode_seed ^ 18231);

	push	160139990				; 098b8ad6H
	call	_srand
	add	esp, 4

; 297  : 
; 298  :         sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	2
	call	ebx

; 299  :         if (sock < 0) 
; 300  :             ABORT("Create TCP socket");
; 301  : 
; 302  :         name.sin_family = AF_INET;
; 303  :         name.sin_addr.s_addr = inet_addr("127.0.0.1");

	push	OFFSET ??_C@_09PFCHIMEP@127?40?40?41@
	mov	DWORD PTR _sock, eax
	mov	WORD PTR _name$[ebp], si
	call	DWORD PTR __imp__inet_addr@4
	mov	DWORD PTR _name$[ebp+4], eax

; 304  :         name.sin_port = htons((short)port);

	movzx	eax, WORD PTR _port
	push	eax
	call	edi

; 305  : 
; 306  :         for (i = 0; i < 60; i++) {

	mov	ebx, DWORD PTR __imp__connect@12
	xor	esi, esi
	mov	edi, DWORD PTR __imp__Sleep@4
	mov	WORD PTR _name$[ebp+2], ax
	npad	2
$LL16@protocol_i:

; 307  :             lprintf("Station B is connecting station A (TCP port %u) ... ", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
	call	_lprintf

; 308  :             fflush(stdout);

	push	1
	call	___acrt_iob_func
	add	esp, 12					; 0000000cH
	push	eax
	call	_fflush
	add	esp, 4

; 309  : 
; 310  :             if (connect(sock, (struct sockaddr *)&name, sizeof(struct sockaddr_in)) < 0) {

	lea	eax, DWORD PTR _name$[ebp]
	push	16					; 00000010H
	push	eax
	push	DWORD PTR _sock
	call	ebx
	test	eax, eax
	jns	$LN26@protocol_i

; 311  :                 lprintf("Failed!\n");

	push	OFFSET ??_C@_08OPNBKLNK@Failed?$CB?6@
	call	_lprintf
	add	esp, 4

; 312  :                 Sleep(2000);

	push	2000					; 000007d0H
	call	edi
	inc	esi
	cmp	esi, 60					; 0000003cH
	jl	SHORT $LL16@protocol_i
$LN18@protocol_i:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 522  :             return _time64(_Time);

	push	OFFSET _epoch
	call	__time64
	add	esp, 4
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c

; 322  :         send(sock, (char *)&epoch, sizeof(epoch), 0);

	push	0
	push	8
	push	OFFSET _epoch
	push	DWORD PTR _sock
	call	DWORD PTR __imp__send@16
$LN24@protocol_i:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h

; 499  :             return _localtime64(_Time);

	push	OFFSET _epoch
	call	__localtime64
	add	esp, 4
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c

; 328  :         lprintf("New epoch: %s", asctime(newtime));

	push	eax
	call	_asctime
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
	call	_lprintf

; 329  :         lprintf("=================================================================\n\n");

	push	OFFSET ??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	_lprintf

; 330  :     }
; 331  : 
; 332  :     /* socket options */
; 333  :     {
; 334  :         int timeout_ms = 10; 
; 335  :         int buf_size = 1024 * 64;
; 336  :         int on = 1;
; 337  : 
; 338  :         setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout_ms, sizeof(int));

	mov	esi, DWORD PTR __imp__setsockopt@20
	lea	eax, DWORD PTR _timeout_ms$3[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _timeout_ms$3[ebp], 10	; 0000000aH
	mov	DWORD PTR _buf_size$2[ebp], 65536	; 00010000H
	mov	DWORD PTR _on$1[ebp], 1
	push	4
	push	eax
	push	4101					; 00001005H
	push	65535					; 0000ffffH
	push	DWORD PTR _sock
	call	esi

; 339  :         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout_ms, sizeof(int));

	push	4
	lea	eax, DWORD PTR _timeout_ms$3[ebp]
	push	eax
	push	4102					; 00001006H
	push	65535					; 0000ffffH
	push	DWORD PTR _sock
	call	esi

; 340  : 
; 341  :         setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&buf_size, sizeof(int));

	push	4
	lea	eax, DWORD PTR _buf_size$2[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	push	DWORD PTR _sock
	call	esi

; 342  :         setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size, sizeof(int));

	push	4
	lea	eax, DWORD PTR _buf_size$2[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	push	DWORD PTR _sock
	call	esi

; 343  : 
; 344  :         setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof(on));   

	push	4
	lea	eax, DWORD PTR _on$1[ebp]
	push	eax
	push	1
	push	6
	push	DWORD PTR _sock
	call	esi

; 345  :     }   
; 346  : 
; 347  :     get_ms();

	call	_get_ms

; 348  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@protocol_i:

; 313  :             } else {
; 314  :                 lprintf("Done.\n");

	push	OFFSET ??_C@_06MJLDIBBJ@Done?4?6@
	call	_lprintf
	add	esp, 4

; 315  :                 break;
; 316  :             }
; 317  :         }
; 318  :         if (i == 6)

	cmp	esi, 6
	jne	$LN18@protocol_i

; 319  :             ABORT("Station B failed to connect station A");

	push	OFFSET ??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN40@protocol_i:

; 277  :             lprintf("Station A: Failed to bind TCP port %u", port);

	movzx	eax, WORD PTR _port
	push	eax
	push	OFFSET ??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
	call	_lprintf

; 278  :             ABORT("Station A failed to bind TCP port");

	push	OFFSET ??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 16					; 00000010H
	push	0
	call	_exit
$LN38@protocol_i:
	int	3
_protocol_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _disable_network_layer
_TEXT	SEGMENT
_disable_network_layer PROC				; COMDAT

; 590  :     network_layer_active = 0;

	mov	DWORD PTR _network_layer_active, 0

; 591  : }

	ret	0
_disable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _get_ms
_TEXT	SEGMENT
_tm$ = -16						; size = 16
tv71 = -8						; size = 8
_get_ms	PROC						; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 37   : 	struct _timeb tm;
; 38   : 
; 39   : 	_ftime(&tm);

	lea	eax, DWORD PTR _tm$[ebp]
	push	esi
	push	eax
	call	__ftime64

; 40   : 
; 41   : 	return (unsigned int)(epoch ? (tm.time - epoch) * 1000 + tm.millitm : 0);

	mov	edx, DWORD PTR _epoch
	add	esp, 4
	mov	esi, DWORD PTR _epoch+4
	mov	eax, edx
	or	eax, esi
	je	SHORT $LN3@get_ms
	mov	ecx, DWORD PTR _tm$[ebp]
	mov	eax, DWORD PTR _tm$[ebp+4]
	sub	ecx, edx
	push	0
	push	1000					; 000003e8H
	sbb	eax, esi
	push	eax
	push	ecx
	call	__allmul
	mov	esi, eax
	mov	ecx, edx
	movzx	eax, WORD PTR _tm$[ebp+8]
	cdq
	add	eax, esi
	adc	ecx, edx
	mov	DWORD PTR tv71[ebp+4], ecx

; 42   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@get_ms:
	xorps	xmm0, xmm0

; 40   : 
; 41   : 	return (unsigned int)(epoch ? (tm.time - epoch) * 1000 + tm.millitm : 0);

	movlpd	QWORD PTR tv71[ebp], xmm0
	mov	eax, DWORD PTR tv71[ebp]

; 42   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_get_ms	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$dead$ = ecx

; 499  :             return _localtime64(_Time);

	push	OFFSET _epoch
	call	__localtime64
	add	esp, 4

; 500  :         }

	ret	0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = ecx

; 522  :             return _time64(_Time);

	push	ecx
	call	__time64
	add	esp, 4

; 523  :         }

	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	esi, DWORD PTR __Format$[ebp]
	push	1
	call	___acrt_iob_func
	add	esp, 4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	eax
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _socket_init
_TEXT	SEGMENT
_WSAData$ = -400					; size = 400
_socket_init PROC					; COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H

; 23   :     WORD wVersionRequested;
; 24   :     WSADATA WSAData;
; 25   : 	int status;
; 26   : 
; 27   :     wVersionRequested = MAKEWORD(1,1);
; 28   :     status = WSAStartup(wVersionRequested, &WSAData);

	lea	eax, DWORD PTR _WSAData$[ebp]
	push	eax
	push	257					; 00000101H
	call	DWORD PTR __imp__WSAStartup@8

; 29   :     if (status != 0) {

	test	eax, eax
	jne	SHORT $LN6@socket_ini

; 32   :     }
; 33   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@socket_ini:

; 30   :         printf("Windows Socket DLL Error\n");

	push	OFFSET ??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
	call	_printf
	add	esp, 4

; 31   : 	    exit(0);

	push	0
	call	_exit
$LN4@socket_ini:
	int	3
_socket_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _station_name
_TEXT	SEGMENT
_station_name PROC					; COMDAT

; 117  :     return (char *)(station == 'a' ? "A" : station == 'b' ? "B" : "XXX");

	mov	ecx, DWORD PTR _station
	cmp	ecx, 97					; 00000061H
	jne	SHORT $LN3@station_na
	mov	eax, OFFSET ??_C@_01FHEEJDEE@A@

; 118  : }

	ret	0
$LN3@station_na:

; 117  :     return (char *)(station == 'a' ? "A" : station == 'b' ? "B" : "XXX");

	cmp	ecx, 98					; 00000062H
	mov	eax, OFFSET ??_C@_01HMGJMAIH@B@
	mov	edx, OFFSET ??_C@_03MAMPKPPK@XXX@
	cmovne	eax, edx

; 118  : }

	ret	0
_station_name ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _config
_TEXT	SEGMENT
_fname$ = -1024						; size = 1024
_config	PROC						; COMDAT
; _argc$ = ecx
; _argv$ = edx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx

; 138  : 	char fname[1024];
; 139  : 	int opt;
; 140  : 
; 141  : 	if (argc < 2) {

	cmp	edi, 2
	jl	$usage$54

; 163  : 	}
; 164  : 
; 165  : 	strcpy(fname, "");
; 166  : 
; 167  : 	while ((opt = getopt_long(argc, argv, OPT_SHORT, intopts, NULL)) != -1) {

	sub	esp, 12					; 0000000cH
	mov	BYTE PTR _fname$[ebp], 0
	call	_getopt_int
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$LN3@config
$LL2@config:

; 168  : 		switch (opt) {

	add	eax, -63				; ffffffc1H
	cmp	eax, 54					; 00000036H
	ja	$LN21@config
	movzx	eax, BYTE PTR $LN45@config[eax]
	jmp	DWORD PTR $LN46@config[eax*4]
$LN11@config:
	xorps	xmm0, xmm0

; 169  : 		case '?':
; 170  : 			goto usage;
; 171  : 
; 172  : 		case 'u':
; 173  : 			ber = 0.0;

	movsd	QWORD PTR _ber, xmm0

; 174  : 			break;

	jmp	$LN4@config
$LN12@config:

; 175  : 
; 176  : 		case 'f':
; 177  : 			mode_flood = 1;

	mov	DWORD PTR _mode_flood, 1

; 178  : 			break;

	jmp	$LN4@config
$LN13@config:

; 179  : 
; 180  : 		case 'i':
; 181  : 			mode_ibib = 1;

	mov	DWORD PTR _mode_ibib, 1

; 182  : 			break;

	jmp	$LN4@config
$LN14@config:

; 183  : 
; 184  : 		case 'n':
; 185  : 			strcpy(fname, "nul");

	mov	DWORD PTR _fname$[ebp], 7107950		; 006c756eH

; 186  : 			break;

	jmp	$LN4@config
$LN15@config:

; 187  : 
; 188  : 		case 'd':
; 189  : 			debug_mask = atoi(optarg);

	push	DWORD PTR _optarg
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _debug_mask, eax

; 190  : 			break;

	jmp	$LN4@config
$LN16@config:

; 191  : 
; 192  : 		case 'p':
; 193  : 			port = (unsigned short)atoi(optarg);

	push	DWORD PTR _optarg
	call	_atoi
	add	esp, 4
	mov	WORD PTR _port, ax

; 194  : 			break;

	jmp	SHORT $LN4@config
$LN17@config:

; 195  : 
; 196  : 		case 'b':
; 197  : 			ber = strtod(optarg, 0);

	push	0
	push	DWORD PTR _optarg
	call	_strtod
	fstp	QWORD PTR _ber

; 198  : 			if (ber >= 1.0) {

	movsd	xmm0, QWORD PTR _ber
	add	esp, 8
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jae	$LN37@config
	jmp	SHORT $LN4@config
$LN19@config:

; 200  : 				goto usage;
; 201  : 			}
; 202  : 			break;
; 203  : 
; 204  : 		case 'l':
; 205  : 			strcpy(fname, optarg);

	mov	ecx, DWORD PTR _optarg
	lea	edx, DWORD PTR _fname$[ebp]
	sub	edx, ecx
$LL32@config:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx-1], al
	test	al, al
	jne	SHORT $LL32@config

; 206  : 			break;

	jmp	SHORT $LN4@config
$LN20@config:

; 207  : 
; 208  : 		case 't':
; 209  : 			mode_life = atoi(optarg) * 1000; /* ms */

	push	DWORD PTR _optarg
	call	_atoi
	add	esp, 4
	imul	eax, eax, 1000
	mov	DWORD PTR _mode_life, eax
$LN4@config:

; 163  : 	}
; 164  : 
; 165  : 	strcpy(fname, "");
; 166  : 
; 167  : 	while ((opt = getopt_long(argc, argv, OPT_SHORT, intopts, NULL)) != -1) {

	sub	esp, 12					; 0000000cH
	mov	edx, esi
	mov	ecx, edi
	call	_getopt_int
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	$LL2@config
$LN3@config:

; 215  : 		}
; 216  : 	}
; 217  : 
; 218  : 	if (optind == argc) 

	mov	ecx, DWORD PTR _optind
	cmp	ecx, edi
	je	$usage$54

; 219  : 		goto usage;
; 220  : 
; 221  : 	station = tolower(argv[optind++][0]);

	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	mov	DWORD PTR _optind, ecx
	movsx	eax, BYTE PTR [eax]
	push	eax
	call	_tolower
	add	esp, 4
	mov	DWORD PTR _station, eax

; 222  : 	if (station != 'a' && station != 'b')

	cmp	eax, 97					; 00000061H
	je	SHORT $LN7@config
	cmp	eax, 98					; 00000062H
	jne	$LN53@config
	jmp	SHORT $LN7@config
$LN21@config:

; 210  : 			break;
; 211  : 
; 212  : 		default:
; 213  : 			printf("ERROR: Unsupported option\n");

	push	OFFSET ??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
	call	_printf
	add	esp, 4

; 214  : 			goto usage;

	jmp	$usage$54
$LN7@config:

; 224  : 
; 225  : 	if (fname[0] == 0) {

	cmp	BYTE PTR _fname$[ebp], 0
	jne	$LN24@config

; 226  : 		strcpy(fname, argv[0]);

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR _fname$[ebp]
	sub	edx, ecx
$LL33@config:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx-1], al
	test	al, al
	jne	SHORT $LL33@config

; 227  : 		if (stricmp(fname + strlen(fname) - 4, ".exe") == 0)

	lea	ecx, DWORD PTR _fname$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL47@config:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL47@config
	sub	ecx, edx
	push	OFFSET ??_C@_04JLMDILM@?4exe@
	lea	eax, DWORD PTR _fname$[ebp+ecx-4]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@config

; 228  : 			*(fname + strlen(fname) - 4) = 0;

	lea	ecx, DWORD PTR _fname$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL48@config:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL48@config
	sub	ecx, edx
	mov	BYTE PTR _fname$[ebp+ecx-4], al
$LN25@config:

; 229  : 		strcat(fname, station == 'a' ? "-A.log" : "-B.log");

	cmp	DWORD PTR _station, 97			; 00000061H
	mov	edx, OFFSET ??_C@_06GOMLAJLH@?9A?4log@
	mov	eax, OFFSET ??_C@_06OIFPHLBJ@?9B?4log@
	cmovne	edx, eax
	mov	esi, edx
$LL49@config:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL49@config
	lea	edi, DWORD PTR _fname$[ebp]
	sub	edx, esi
	dec	edi
$LL50@config:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL50@config
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
$LN24@config:

; 230  : 	}
; 231  : 
; 232  : 	if (stricmp(fname, "nul") == 0)

	lea	eax, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_03JODACOMD@nul@
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@config

; 233  : 		log_file = NULL;

	mov	DWORD PTR _log_file, eax
	jmp	SHORT $LN28@config
$LN26@config:

; 234  : 	else if ((log_file = fopen(fname, "w")) == NULL) 

	lea	eax, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w@
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _log_file, eax
	test	eax, eax
	jne	SHORT $LN28@config

; 235  : 		printf("WARNING: Failed to create log file \"%s\": %s\n", fname, strerror(errno));

	call	__errno
	push	DWORD PTR [eax]
	call	_strerror
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
	call	_printf
	add	esp, 12					; 0000000cH
$LN28@config:

; 236  : 
; 237  : 	lprintf(

	call	_station_name
	push	eax
	push	OFFSET ??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	_lprintf

; 238  : 		"=============================================================\n"
; 239  : 		"                    Station %s                               \n"
; 240  : 		"-------------------------------------------------------------\n",
; 241  : 		station_name());
; 242  : 
; 243  : 	lprintf("Protocol.lib, version %s, jiangyanjun0718@bupt.edu.cn\n", VERSION, __DATE__);

	push	OFFSET ??_C@_0M@KDHDHOOB@May?512?52022@
	push	OFFSET ??_C@_03EMGHBCAM@4?40@
	push	OFFSET ??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
	call	_lprintf
	add	esp, 20					; 00000014H

; 244  : 	lprintf("Channel: %d bps, %d ms propagation delay, bit error rate ", CHAN_BPS, CHAN_DELAY);

	push	270					; 0000010eH
	push	8000					; 00001f40H
	push	OFFSET ??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
	call	_lprintf

; 245  : 	if (ber > 0.0)

	movsd	xmm0, QWORD PTR _ber
	add	esp, 12					; 0000000cH
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN29@config

; 246  : 		lprintf("%.1E\n", ber);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05KDIEGDNJ@?$CF?41E?6@
	call	_lprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@config
$LN29@config:

; 247  : 	else
; 248  : 		lprintf("0\n");

	push	OFFSET ??_C@_02NODKCLPH@0?6@
	call	_lprintf
	add	esp, 4
$LN30@config:

; 249  : 	lprintf("Log file \"%s\", TCP port %d, debug mask 0x%02x\n", fname, port, debug_mask);

	push	DWORD PTR _debug_mask
	movzx	eax, WORD PTR _port
	push	eax
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
	call	_lprintf
	add	esp, 16					; 00000010H

; 250  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@config:

; 199  : 				printf("Bad BER %.3f\n", ber);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
	call	_printf
	add	esp, 12					; 0000000cH
$usage$54:

; 142  : 	usage:
; 143  : 		printf("\nUsage:\n  %s <options> <station-name>\n", argv[0]);

	push	DWORD PTR [esi]
	push	OFFSET ??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
	call	_printf

; 144  : 		printf(

	mov	eax, DWORD PTR [esi]
	push	eax
	push	eax
	push	59144					; 0000e708H
	push	OFFSET ??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
	call	_printf
	add	esp, 24					; 00000018H

; 145  : 			"\nOptions : \n"
; 146  : 			"    -?, --help : print this\n"
; 147  : 			"    -u, --utopia : utopia channel (an error-free channel)\n"
; 148  : 			"    -f, --flood : flood traffic\n"
; 149  : 			"    -i, --ibib  : set station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...\n"
; 150  : 			"    -n, --nolog : do not create log file\n"
; 151  : 			"    -d, --debug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)\n"
; 152  : 			"    -p, --port=<port#> : TCP port number (default: %u)\n"
; 153  : 			"    -b, --ber=<ber> : Bit Error Rate (received data only)\n"
; 154  : 			"    -l, --log=<filename> : using assigned file as log file\n"
; 155  : 			"    -t, --ttl=<seconds> : set time-to-live\n"
; 156  : 			"\n"
; 157  : 			"i.e.\n"
; 158  : 			"    %s -fd3 -b 1e-4 A\n"
; 159  : 			"    %s --flood --debug=3 --ber=1e-4 A\n"
; 160  : 			"\n",
; 161  : 			DEFAULT_PORT, argv[0], argv[0]);
; 162  : 		exit(0);

	push	0
	call	_exit
$LN53@config:

; 223  : 		ABORT("Station name must be 'A' or 'B'");

	push	OFFSET ??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN51@config:
	npad	1
$LN46@config:

; 250  : }

	DD	$usage$54
	DD	$LN17@config
	DD	$LN15@config
	DD	$LN12@config
	DD	$LN13@config
	DD	$LN19@config
	DD	$LN14@config
	DD	$LN16@config
	DD	$LN20@config
	DD	$LN11@config
	DD	$LN21@config
$LN45@config:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	10					; 0000000aH
	DB	6
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	9
_config	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _sq_len
_TEXT	SEGMENT
_sq_len	PROC						; COMDAT

; 366  :     return (sq_tail + SQ_SIZE - sq_head) % SQ_SIZE;

	mov	eax, DWORD PTR _sq_tail
	sub	eax, DWORD PTR _sq_head
	add	eax, 131072				; 00020000H
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN3@sq_len
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN3@sq_len:

; 367  : }

	ret	0
_sq_len	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _phl_sq_len
_TEXT	SEGMENT
_phl_sq_len PROC					; COMDAT

; 371  :     return sq_len();

	jmp	_sq_len
_phl_sq_len ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _send_byte
_TEXT	SEGMENT
_byte$ = -4						; size = 1
_send_byte PROC						; COMDAT
; _byte$ = cl

; 375  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 376  :     inform_phl_ready = 1;
; 377  : 
; 378  :     if (send_bytes_allowed && sq_head == sq_tail) {

	cmp	DWORD PTR _send_bytes_allowed, 0
	mov	edx, DWORD PTR _sq_tail
	mov	BYTE PTR _byte$[ebp], cl
	mov	DWORD PTR _inform_phl_ready, 1
	je	SHORT $LN5@send_byte
	cmp	DWORD PTR _sq_head, edx
	jne	SHORT $LN5@send_byte

; 379  :         send(sock, (char *)&byte, 1, 0);

	push	0
	push	1
	lea	eax, DWORD PTR _byte$[ebp]
	push	eax
	push	DWORD PTR _sock
	call	DWORD PTR __imp__send@16

; 380  :         send_bytes_allowed--;

	dec	DWORD PTR _send_bytes_allowed

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@send_byte:

; 381  :         return;
; 382  :     }
; 383  : 
; 384  :     if (sq_len() == SQ_SIZE - 1)

	call	_sq_len
	cmp	eax, 131071				; 0001ffffH
	je	SHORT $LN11@send_byte

; 386  : 
; 387  :     sq[sq_tail] = byte;
; 388  :     sq_inc(sq_tail, 1);

	lea	eax, DWORD PTR [edx+1]
	mov	BYTE PTR _sq[edx], cl
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN8@send_byte
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN8@send_byte:
	mov	DWORD PTR _sq_tail, eax

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@send_byte:

; 385  :         ABORT("Physical Layer Sending Queue overflow");

	push	OFFSET ??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN9@send_byte:
	int	3
_send_byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _send_sq_data
_TEXT	SEGMENT
_send_sq_data PROC					; COMDAT
; _start$ = ecx
; _end1$ = edx

; 405  : {

	push	ecx

; 406  :     int ret;
; 407  : 
; 408  :     if (start >= end1) 

	cmp	ecx, edx
	jb	SHORT $LN2@send_sq_da

; 409  :         return 0;

	xor	eax, eax
$LN1@send_sq_da:

; 415  :     }
; 416  : 
; 417  :     return ret;
; 418  : }

	pop	ecx
	ret	0
$LN2@send_sq_da:

; 410  : 
; 411  :     ret = send(sock, (char *)&sq[start], end1 - start, 0);

	push	0
	sub	edx, ecx
	lea	eax, DWORD PTR _sq[ecx]
	push	edx
	push	eax
	push	DWORD PTR _sock
	call	DWORD PTR __imp__send@16

; 412  :     if (ret <= 0) {

	test	eax, eax
	jg	SHORT $LN1@send_sq_da

; 413  :         lprintf("TCP Disconnected.\n");

	push	OFFSET ??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
	call	_lprintf
	add	esp, 4

; 414  :         exit(0);

	push	0
	call	_exit
$LN5@send_sq_da:
	int	3
_send_sq_data ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _socket_send
_TEXT	SEGMENT
_socket_send PROC					; COMDAT

; 421  : {

	push	ecx

; 422  :     static int last_ts = 0;
; 423  :     int n, send_tail = sq_head, send_bytes;
; 424  : 
; 425  :     if (last_ts == 0) 

	mov	eax, DWORD PTR ?last_ts@?1??socket_send@@9@9
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN10@socket_sen

; 426  :         last_ts = now;
; 427  : 
; 428  :     if (now <= last_ts) 

	mov	esi, DWORD PTR _now
	cmp	esi, eax
	jle	SHORT $LN1@socket_sen

; 429  :         return;
; 430  : 
; 431  :     send_bytes_allowed = (now - last_ts) * CHAN_BPS / 8 / 1000 * 2;

	sub	esi, eax
	add	esi, esi
	mov	DWORD PTR _send_bytes_allowed, esi
	call	_sq_len

; 432  :     n = sq_len();
; 433  :     if (n > send_bytes_allowed)
; 434  :         n = send_bytes_allowed;
; 435  :     sq_inc(send_tail, n);

	mov	ecx, DWORD PTR _sq_head
	cmp	eax, esi
	cmovle	esi, eax
	add	esi, ecx
	and	esi, -2147352577			; 8001ffffH
	jns	SHORT $LN8@socket_sen
	dec	esi
	or	esi, -131072				; fffe0000H
	inc	esi
$LN8@socket_sen:
	cmp	esi, ecx

; 436  : 
; 437  :     if (send_tail >= sq_head) 

	jl	SHORT $LN5@socket_sen

; 438  :         send_bytes = send_sq_data(sq_head, send_tail);

	mov	edx, esi
	call	_send_sq_data
	mov	edi, eax
	jmp	SHORT $LN6@socket_sen
$LN5@socket_sen:

; 439  :     else {
; 440  :         send_bytes = send_sq_data(sq_head, SQ_SIZE);

	mov	edx, 131072				; 00020000H
	call	_send_sq_data

; 441  :         send_bytes += send_sq_data(0, send_tail);

	mov	edx, esi
	xor	ecx, ecx
	mov	edi, eax
	call	_send_sq_data
	add	edi, eax
$LN6@socket_sen:

; 442  :     }
; 443  : 
; 444  :     sq_inc(sq_head, send_bytes);

	mov	eax, DWORD PTR _sq_head
	add	eax, edi
	and	eax, -2147352577			; 8001ffffH
	jns	SHORT $LN9@socket_sen
	dec	eax
	or	eax, -131072				; fffe0000H
	inc	eax
$LN9@socket_sen:

; 445  :     send_bytes_allowed -= send_bytes;

	sub	DWORD PTR _send_bytes_allowed, edi
	mov	DWORD PTR _sq_head, eax
$LN10@socket_sen:

; 446  : 
; 447  :     last_ts = now;
; 448  : }

	mov	eax, DWORD PTR _now
	mov	DWORD PTR ?last_ts@?1??socket_send@@9@9, eax
$LN1@socket_sen:
	pop	edi
	pop	esi
	pop	ecx
	ret	0
_socket_send ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _socket_recv
_TEXT	SEGMENT
_socket_recv PROC					; COMDAT

; 465  : {

	push	ebx
	push	esi
	push	edi

; 466  :     struct BLK *blk;
; 467  :     unsigned char *p;
; 468  : 
; 469  :     blk = (struct BLK *)malloc(sizeof(struct BLK));

	push	260					; 00000104H
	call	_malloc
	mov	edi, eax
	add	esp, 4

; 470  :     if (blk == NULL) 

	test	edi, edi
	je	$LN19@socket_rec

; 472  : 
; 473  :     blk->rptr = 0;
; 474  :     blk->wptr = recv(sock, (char *)blk->data, BLKSIZE, 0);

	push	0
	push	242					; 000000f2H
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+4], 0
	push	eax
	push	DWORD PTR _sock
	call	DWORD PTR __imp__recv@16
	mov	edx, eax
	mov	DWORD PTR [edi+8], edx

; 475  :     if (blk->wptr <= 0) {

	test	edx, edx
	jle	$LN20@socket_rec

; 478  :     }
; 479  :     nbits += blk->wptr * 4;
; 480  : 
; 481  :     /* Impose noise */
; 482  :     if (ber != 0.0) {

	movsd	xmm2, QWORD PTR _ber
	ucomisd	xmm2, QWORD PTR __real@0000000000000000
	mov	eax, DWORD PTR _nbits
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _nbits, ecx
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@socket_rec

; 483  :         int a;
; 484  :         double rate, fact;
; 485  : 
; 486  :         rate = (double)noise / nbits;

	movd	xmm1, DWORD PTR _noise
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm1, xmm0

; 487  :         fact = rate > ber ? 3.5 : 6.0;

	comisd	xmm1, xmm2
	jbe	SHORT $LN13@socket_rec
	movsd	xmm3, QWORD PTR __real@400c000000000000
	jmp	SHORT $LN14@socket_rec
$LN13@socket_rec:
	movsd	xmm3, QWORD PTR __real@4018000000000000
$LN14@socket_rec:

; 488  :         a = (int)((1.0 - pow(1.0 - ber, fact * blk->wptr)) * (RAND_MAX + 1.0) + 0.5);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movd	xmm1, edx
	subsd	xmm0, xmm2
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, xmm3
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@40e0000000000000
	addsd	xmm1, QWORD PTR __real@3fe0000000000000
	cvttsd2si esi, xmm1

; 489  :         if (rand() <= a) {

	call	_rand
	cmp	eax, esi
	jg	SHORT $LN9@socket_rec

; 490  :             p = &blk->data[rand() % blk->wptr];

	call	_rand
	cdq
	idiv	DWORD PTR [edi+8]

; 491  :             if (*p & 0x0f) {

	mov	al, BYTE PTR [edx+edi+16]
	lea	esi, DWORD PTR [edx+edi]
	test	al, 15					; 0000000fH
	je	SHORT $LN9@socket_rec

; 492  :                 *p ^= 1 << (rand() % 8);

	movzx	ebx, al
	call	_rand
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN15@socket_rec
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN15@socket_rec:

; 493  :                 noise++;
; 494  :                 dbg_warning("Impose noise on received data, %u/%u=%.1E\n", noise, nbits, (double)noise / nbits);

	mov	ecx, DWORD PTR _nbits
	btc	ebx, eax
	mov	edx, DWORD PTR _noise
	mov	eax, ecx
	inc	edx
	shr	eax, 31					; 0000001fH
	sub	esp, 8
	mov	BYTE PTR [esi+16], bl
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR _noise, edx
	movd	xmm1, edx
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm0
	movsd	QWORD PTR [esp], xmm1
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
	call	_dbg_warning
	add	esp, 20					; 00000014H
$LN9@socket_rec:

; 495  :             }
; 496  :         }
; 497  :     }
; 498  : 
; 499  :     blk->commit_ts = now + CHAN_DELAY - 10;

	mov	eax, DWORD PTR _now
	add	eax, 260				; 00000104H

; 500  :     blk->link = NULL; 

	mov	DWORD PTR [edi+12], 0

; 501  : 
; 502  :     if (rblk_head == NULL) 

	cmp	DWORD PTR _rblk_head, 0
	mov	DWORD PTR [edi], eax
	jne	SHORT $LN10@socket_rec

; 503  :         rblk_head = rblk_tail = blk;

	mov	DWORD PTR _rblk_head, edi

; 506  :         rblk_tail = blk;
; 507  :     }
; 508  : }

	mov	DWORD PTR _rblk_tail, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN10@socket_rec:

; 504  :     else {
; 505  :         rblk_tail->link = blk;

	mov	eax, DWORD PTR _rblk_tail

; 506  :         rblk_tail = blk;
; 507  :     }
; 508  : }

	mov	DWORD PTR _rblk_tail, edi
	mov	DWORD PTR [eax+12], edi
	pop	edi
	pop	esi
	pop	ebx
	ret	0
$LN19@socket_rec:

; 471  :         ABORT("No enough memory");

	push	OFFSET ??_C@_0BB@IAFLKGG@No?5enough?5memory@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN20@socket_rec:

; 476  :         lprintf("TCP disconnected.\n");

	push	OFFSET ??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
	call	_lprintf
	add	esp, 4

; 477  :         exit(0);

	push	0
	call	_exit
$LN16@socket_rec:
	int	3
_socket_recv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _recv_byte
_TEXT	SEGMENT
_recv_byte PROC						; COMDAT

; 512  :     unsigned char ch;
; 513  :     struct BLK *blk = rblk_head;

	mov	edx, DWORD PTR _rblk_head
	push	ebx
	test	edx, edx

; 514  : 
; 515  :     if (blk == NULL || blk->commit_ts > now) 

	je	SHORT $LN4@recv_byte
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _now
	jg	SHORT $LN4@recv_byte

; 517  : 
; 518  :     ch = blk->data[blk->rptr++];

	mov	eax, DWORD PTR [edx+4]
	mov	bl, BYTE PTR [eax+edx+16]
	inc	eax
	mov	DWORD PTR [edx+4], eax

; 519  :     if (blk->rptr == blk->wptr) {

	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN7@recv_byte

; 520  :         rblk_head = blk->link;

	mov	ecx, DWORD PTR [edx+12]

; 521  :         free(blk);

	push	edx
	mov	DWORD PTR _rblk_head, ecx
	call	_free
	add	esp, 4
$LN7@recv_byte:

; 522  :     } 
; 523  :     
; 524  :     return ch;

	mov	al, bl

; 525  : }

	pop	ebx
	ret	0
$LN4@recv_byte:

; 516  :         ABORT("recv_byte(): Receiving Queue is empty");

	push	OFFSET ??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN9@recv_byte:
	int	3
_recv_byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _scan_timer
_TEXT	SEGMENT
_scan_timer PROC					; COMDAT
; _nr$ = ecx

; 565  : {

	push	esi

; 566  :     int i;
; 567  : 
; 568  :     for (i = 0; i < NTIMER; i++) {

	mov	esi, DWORD PTR _now
	xor	eax, eax
	npad	7
$LL4@scan_timer:

; 569  :         if (timer[i] && timer[i] <= now) {

	mov	edx, DWORD PTR _timer[eax*4]
	test	edx, edx
	je	SHORT $LN2@scan_timer
	cmp	edx, esi
	jle	SHORT $LN8@scan_timer
$LN2@scan_timer:

; 566  :     int i;
; 567  : 
; 568  :     for (i = 0; i < NTIMER; i++) {

	inc	eax
	cmp	eax, 129				; 00000081H
	jl	SHORT $LL4@scan_timer

; 573  :         }
; 574  :     }
; 575  :     return 0;

	xor	eax, eax
	pop	esi

; 576  : }

	ret	0
$LN8@scan_timer:

; 570  :             *nr = i;

	mov	DWORD PTR [ecx], eax

; 571  :             timer[i] = 0;
; 572  :             return i == ACK_TIMER_ID ? ACK_TIMEOUT : DATA_TIMEOUT;

	xor	ecx, ecx
	cmp	eax, 128				; 00000080H
	mov	DWORD PTR _timer[eax*4], 0
	pop	esi
	sete	cl
	lea	eax, DWORD PTR [ecx+3]

; 576  : }

	ret	0
_scan_timer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _network_layer_ready
_TEXT	SEGMENT
_network_layer_ready PROC				; COMDAT

; 595  :     static int last_ts = 0;
; 596  : 
; 597  :     if (!network_layer_active)

	cmp	DWORD PTR _network_layer_active, 0
	push	esi
	je	$LN10@network_la

; 598  :         return 0;
; 599  : 
; 600  :     if (mode_flood) 

	cmp	DWORD PTR _mode_flood, 0
	jne	$LN12@network_la

; 601  :         return 1;
; 602  : 
; 603  :     if ((now - last_ts) * CHAN_BPS / 8 / 1000 < PKT_LEN * 3 / 4)

	mov	esi, DWORD PTR _now
	mov	eax, esi
	sub	eax, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	cmp	eax, 192				; 000000c0H
	jl	SHORT $LN10@network_la

; 604  :         return 0;
; 605  : 
; 606  :     if (station == 'b') {

	cmp	DWORD PTR _station, 98			; 00000062H
	jne	SHORT $LN8@network_la

; 607  :         if (now / 1000 / mode_cycle % 2 != mode_ibib) {

	mov	eax, 274877907				; 10624dd3H
	imul	esi
	mov	eax, 1374389535				; 51eb851fH
	sar	edx, 6
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN11@network_la
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN11@network_la:
	cmp	eax, DWORD PTR _mode_ibib
	je	SHORT $LN7@network_la

; 608  :             if (now - last_ts < 4000 + rand() % 500)

	call	_rand
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	mov	esi, DWORD PTR _now
	mov	eax, esi
	sub	eax, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	add	edx, 4000				; 00000fa0H
	cmp	eax, edx
	jl	SHORT $LN10@network_la
$LN7@network_la:

; 609  :                 return 0;
; 610  :         }
; 611  :         if (now < CHAN_DELAY + 3 * PKT_LEN * 8000 / CHAN_BPS)

	cmp	esi, 1038				; 0000040eH
	jl	SHORT $LN10@network_la
$LN8@network_la:

; 613  :     }
; 614  : 
; 615  :     last_ts = now;

	mov	DWORD PTR ?last_ts@?1??network_layer_ready@@9@9, esi
$LN12@network_la:

; 616  : 
; 617  :     return 1;
; 618  : }

	mov	eax, 1
	pop	esi
	ret	0
$LN10@network_la:

; 612  :             return 0;

	xor	eax, eax
	pop	esi

; 616  : 
; 617  :     return 1;
; 618  : }

	ret	0
_network_layer_ready ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _randA
_TEXT	SEGMENT
_randA	PROC						; COMDAT

; 622  :     static unsigned int holdrand = 0x65109bc4;
; 623  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randA@@9@9, 214013
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randA@@9@9, eax
	shr	eax, 16					; 00000010H
	and	eax, 32767				; 00007fffH

; 624  : }

	ret	0
_randA	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _randB
_TEXT	SEGMENT
_randB	PROC						; COMDAT

; 628  :     static unsigned int holdrand = 0x1e459090;
; 629  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randB@@9@9, 214013
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randB@@9@9, eax
	shr	eax, 16					; 00000010H
	and	eax, 32767				; 00007fffH

; 630  : }

	ret	0
_randB	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _dbg_warning
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_dbg_warning PROC					; COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp

; 709  : 	va_list arg_ptr;
; 710  : 
; 711  : 	if (debug_mask & DBG_WARNING) {

	test	BYTE PTR _debug_mask, 4
	je	SHORT $LN2@dbg_warnin

; 712  : 		va_start(arg_ptr, fmt);
; 713  : 		__v_lprintf(fmt, arg_ptr);

	mov	ecx, DWORD PTR _fmt$[ebp]
	lea	edx, DWORD PTR _fmt$[ebp+4]

; 714  : 		va_end(arg_ptr);
; 715  : 	}
; 716  : }

	pop	ebp

; 712  : 		va_start(arg_ptr, fmt);
; 713  : 		__v_lprintf(fmt, arg_ptr);

	jmp	___v_lprintf
$LN2@dbg_warnin:

; 714  : 		va_end(arg_ptr);
; 715  : 	}
; 716  : }

	pop	ebp
	ret	0
_dbg_warning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _magic_init
_TEXT	SEGMENT
_magic_init PROC					; COMDAT

; 899  :     int i;
; 900  :     for (i = 0; i < NMAGIC; i++) {
; 901  :         head_magic[i] = HEAD_MAGIC;

	movaps	xmm0, XMMWORD PTR __xmm@a5a5e41ba5a5e41ba5a5e41ba5a5e41b
	movups	XMMWORD PTR _head_magic, xmm0
	movups	XMMWORD PTR _head_magic+16, xmm0
	movups	XMMWORD PTR _head_magic+32, xmm0
	movups	XMMWORD PTR _head_magic+48, xmm0
	movups	XMMWORD PTR _head_magic+64, xmm0
	movups	XMMWORD PTR _head_magic+80, xmm0
	movups	XMMWORD PTR _head_magic+96, xmm0
	movups	XMMWORD PTR _head_magic+112, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@f5125a5af5125a5af5125a5af5125a5a
	movups	XMMWORD PTR _foot_magic, xmm0
	movups	XMMWORD PTR _foot_magic+16, xmm0
	movups	XMMWORD PTR _foot_magic+32, xmm0
	movups	XMMWORD PTR _foot_magic+48, xmm0
	movups	XMMWORD PTR _foot_magic+64, xmm0
	movups	XMMWORD PTR _foot_magic+80, xmm0
	movups	XMMWORD PTR _foot_magic+96, xmm0
	movups	XMMWORD PTR _foot_magic+112, xmm0

; 902  :         foot_magic[i] = FOOT_MAGIC;;
; 903  :     }
; 904  : }

	ret	0
_magic_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT _magic_check
_TEXT	SEGMENT
_magic_check PROC					; COMDAT

; 907  : {

	push	ecx

; 908  :     int i;
; 909  : 
; 910  :     for (i = 0; i < NMAGIC; i++) {

	mov	eax, OFFSET _head_magic
$LL4@magic_chec:

; 911  : 		if (head_magic[i] != HEAD_MAGIC)

	cmp	DWORD PTR [eax], -1515854821		; a5a5e41bH
	jne	SHORT $exit$26

; 908  :     int i;
; 909  : 
; 910  :     for (i = 0; i < NMAGIC; i++) {

	add	eax, 4
	cmp	eax, OFFSET _head_magic+128
	jl	SHORT $LL4@magic_chec

; 912  : 			goto exit;
; 913  :     }
; 914  : 
; 915  :     for (i = 0; i < NMAGIC; i++) {

	mov	eax, OFFSET _foot_magic
	npad	3
$LL7@magic_chec:

; 916  : 		if (foot_magic[i] != FOOT_MAGIC)

	cmp	DWORD PTR [eax], -183346598		; f5125a5aH
	jne	SHORT $exit$26

; 912  : 			goto exit;
; 913  :     }
; 914  : 
; 915  :     for (i = 0; i < NMAGIC; i++) {

	add	eax, 4
	cmp	eax, OFFSET _foot_magic+128
	jl	SHORT $LL7@magic_chec

; 923  : 
; 924  : }

	pop	ecx
	ret	0
$exit$26:

; 917  : 			goto exit;
; 918  :     }
; 919  : 	return;
; 920  : 
; 921  : exit:
; 922  : 	ABORT("Memory used by 'protocol.lib' is corrupted by your program");

	push	OFFSET ??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
	push	OFFSET ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	_lprintf
	add	esp, 8
	push	0
	call	_exit
$LN24@magic_chec:
	int	3
_magic_check ENDP
_TEXT	ENDS
END
