; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30142.1 

	TITLE	c:\users\sharksouth\onedrive - bupt.edu.cn\学习资料\计算机网络\课程实验\lab1-2022(win+linux)\lab1-windows-vs2019\win32-release\getopt.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@		; `string'
PUBLIC	??_C@_02BAABKJLB@?9?9@				; `string'
PUBLIC	??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ ; `string'
PUBLIC	??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ ; `string'
PUBLIC	??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ ; `string'
PUBLIC	??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ ; `string'
PUBLIC	_optind
PUBLIC	_optarg
PUBLIC	_opterr
EXTRN	_getenv:PROC
EXTRN	_strchr:PROC
EXTRN	_strncmp:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___acrt_iob_func:PROC
_optarg	DD	01H DUP (?)
_BSS	ENDS
_optind	DD	01H
_DATA	ENDS
;	COMDAT ??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
CONST	SEGMENT
??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ DB '%s: option'
	DB	' requires an argument -- %c', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
CONST	SEGMENT
??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ DB '%s: illeg'
	DB	'al option -- %c', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `%c%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `--%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
CONST	SEGMENT
??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ DB '%'
	DB	's: option `%s'' requires an argument', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `%c%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `--%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
CONST	SEGMENT
??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ DB '%s:'
	DB	' option `%s'' is ambiguous', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
CONST	SEGMENT
??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@ DB 'POSIXLY_CORRECT', 00H ; `string'
_opterr	DD	01H
PUBLIC	_getopt_int
PUBLIC	__getopt_internal
PUBLIC	_fprintf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
	ALIGN	4

___getopt_initialized DD 01H DUP (?)
_nextchar DD	01H DUP (?)
_first_nonopt DD 01H DUP (?)
_ordering DD	01H DUP (?)
_last_nonopt DD	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vfprintf_l PROC					; COMDAT
; __Stream$ = ecx
; __Format$ = edx

; 644  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT _exchange
_TEXT	SEGMENT
_bottom$1$ = -12					; size = 4
_argv$1$ = -8						; size = 4
_top$1$ = -4						; size = 4
_exchange PROC						; COMDAT
; _argv$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 170  :     int bottom = first_nonopt;

	mov	ebx, DWORD PTR _first_nonopt
	mov	eax, ebx
	push	esi
	push	edi

; 171  :     int middle = last_nonopt;
; 172  :     int top = optind;

	mov	edi, DWORD PTR _optind
	mov	esi, ecx

; 173  :     char *tem;
; 174  : 
; 175  :     /* Exchange the shorter segment with the far end of the inter segment.
; 176  :        That puts the shorter segment into the right place.
; 177  :        It leaves the inter segment in the right place overall,
; 178  :        but it consists of two parts that need to be swapped next.  */
; 179  : 
; 180  :     while (top > middle && middle > bottom)

	mov	ecx, DWORD PTR _last_nonopt
	mov	edx, edi
	mov	DWORD PTR _argv$1$[ebp], esi
	mov	DWORD PTR _bottom$1$[ebp], eax
	mov	DWORD PTR _top$1$[ebp], edx
	cmp	edx, ecx
	jle	$LN3@exchange
$LL2@exchange:
	cmp	ecx, eax
	jle	$LN26@exchange

; 181  :     {
; 182  : 	if (top - middle > middle - bottom)

	mov	edi, edx
	mov	ebx, ecx
	sub	edi, ecx
	sub	ebx, eax
	cmp	edi, ebx
	jle	SHORT $LN10@exchange

; 186  : 	    register int i;
; 187  : 
; 188  : 	    /* Swap it with the top part of the top segment.  */
; 189  : 	    for (i = 0; i < len; i++)

	test	ebx, ebx
	jle	SHORT $LN5@exchange

; 183  : 	{
; 184  : 	    /* Bottom segment is the short one.  */
; 185  : 	    int len = middle - bottom;

	lea	edx, DWORD PTR [esi+eax*4]
	add	eax, edi
	mov	edi, ebx
	lea	esi, DWORD PTR [esi+eax*4]
$LL6@exchange:

; 190  : 	    {
; 191  : 		tem = argv[bottom + i];

	mov	ecx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]

; 192  : 		argv[bottom + i] = argv[top - (middle - bottom) + i];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [edx-4], eax

; 193  : 		argv[top - (middle - bottom) + i] = tem;

	mov	DWORD PTR [esi-4], ecx
	sub	edi, 1
	jne	SHORT $LL6@exchange
	mov	eax, DWORD PTR _bottom$1$[ebp]
	mov	ecx, DWORD PTR _last_nonopt
	mov	edx, DWORD PTR _top$1$[ebp]
	mov	esi, DWORD PTR _argv$1$[ebp]
$LN5@exchange:

; 194  : 	    }
; 195  : 	    /* Exclude the moved bottom segment from further swapping.  */
; 196  : 	    top -= len;

	sub	edx, ebx
	mov	DWORD PTR _top$1$[ebp], edx

; 197  : 	}

	jmp	SHORT $LN11@exchange
$LN10@exchange:

; 202  : 	    register int i;
; 203  : 
; 204  : 	    /* Swap it with the bottom part of the bottom segment.  */
; 205  : 	    for (i = 0; i < len; i++)

	test	edi, edi
	jle	SHORT $LN8@exchange

; 198  : 	else
; 199  : 	{
; 200  : 	    /* Top segment is the short one.  */
; 201  : 	    int len = top - middle;

	lea	esi, DWORD PTR [esi+ecx*4]
	mov	ebx, edi
	mov	ecx, DWORD PTR _argv$1$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	npad	2
$LL18@exchange:

; 206  : 	    {
; 207  : 		tem = argv[bottom + i];

	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+4]

; 208  : 		argv[bottom + i] = argv[middle + i];

	mov	ecx, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [eax-4], ecx

; 209  : 		argv[middle + i] = tem;

	mov	DWORD PTR [esi-4], edx
	sub	ebx, 1
	jne	SHORT $LL18@exchange
	mov	eax, DWORD PTR _bottom$1$[ebp]
	mov	ecx, DWORD PTR _last_nonopt
	mov	edx, DWORD PTR _top$1$[ebp]
	mov	esi, DWORD PTR _argv$1$[ebp]
$LN8@exchange:

; 210  : 	    }
; 211  : 	    /* Exclude the moved top segment from further swapping.  */
; 212  : 	    bottom += len;

	add	eax, edi
	mov	DWORD PTR _bottom$1$[ebp], eax
$LN11@exchange:

; 173  :     char *tem;
; 174  : 
; 175  :     /* Exchange the shorter segment with the far end of the inter segment.
; 176  :        That puts the shorter segment into the right place.
; 177  :        It leaves the inter segment in the right place overall,
; 178  :        but it consists of two parts that need to be swapped next.  */
; 179  : 
; 180  :     while (top > middle && middle > bottom)

	cmp	edx, ecx
	jg	$LL2@exchange
$LN26@exchange:
	mov	ebx, DWORD PTR _first_nonopt
	mov	edi, DWORD PTR _optind
$LN3@exchange:

; 213  : 	}
; 214  :     }
; 215  : 
; 216  :     /* Update records for the slots the non-options now occupy.  */
; 217  : 
; 218  :     first_nonopt += (optind - last_nonopt);

	mov	eax, edi

; 219  :     last_nonopt = optind;

	mov	DWORD PTR _last_nonopt, edi
	sub	eax, ecx
	pop	edi
	add	ebx, eax
	pop	esi
	mov	DWORD PTR _first_nonopt, ebx
	pop	ebx

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_exchange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT __getopt_initialize
_TEXT	SEGMENT
_optstring$dead$ = 8					; size = 4
__getopt_initialize PROC				; COMDAT
; _argc$dead$ = ecx
; _argv$dead$ = edx

; 226  :     /* Start processing options with ARGV-element 1 (since ARGV-element 0
; 227  :        is the program name); the sequence of previously skipped
; 228  :        non-option ARGV-elements is empty.  */
; 229  : 
; 230  :     first_nonopt = last_nonopt = optind;

	mov	eax, DWORD PTR _optind

; 231  : 
; 232  :     nextchar = NULL;
; 233  : 
; 234  :     /* Determine how to handle the ordering of options and nonoptions.  */
; 235  : 
; 236  :     if (optstring[0] == '-')
; 237  :     {
; 238  : 	ordering = RETURN_IN_ORDER;
; 239  : 	++optstring;
; 240  :     }
; 241  :     else if (optstring[0] == '+')
; 242  :     {
; 243  : 	ordering = REQUIRE_ORDER;
; 244  : 	++optstring;
; 245  :     }
; 246  :     else if (getenv ("POSIXLY_CORRECT") != NULL)

	push	OFFSET ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
	mov	DWORD PTR _last_nonopt, eax
	mov	DWORD PTR _first_nonopt, eax
	mov	DWORD PTR _nextchar, 0
	call	_getenv
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax

; 247  : 	ordering = REQUIRE_ORDER;
; 248  :     else
; 249  : 	ordering = PERMUTE;
; 250  : 
; 251  :     return optstring;

	mov	DWORD PTR _ordering, eax
	mov	eax, OFFSET ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@

; 252  : }

	ret	0
__getopt_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT __getopt_internal
_TEXT	SEGMENT
tv934 = -28						; size = 4
tv923 = -24						; size = 4
_ambig$1$ = -24						; size = 4
_argc$1$ = -20						; size = 4
_nameend$1$ = -16					; size = 4
_optstring$1$ = -12					; size = 4
_argv$1$ = -8						; size = 4
tv961 = -1						; size = 1
tv931 = -1						; size = 1
tv930 = -1						; size = 1
_optstring$dead$ = 8					; size = 4
_intopts$dead$ = 12					; size = 4
_intind$dead$ = 16					; size = 4
_int_only$dead$ = 20					; size = 4
__getopt_internal PROC					; COMDAT
; _argc$ = ecx
; _argv$ = edx

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _optstring$1$[ebp], OFFSET ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
	mov	DWORD PTR _argc$1$[ebp], edi
	mov	ebx, edx
	mov	DWORD PTR _argv$1$[ebp], ebx

; 313  :     int print_errors = opterr;
; 314  :     if (optstring[0] == ':')
; 315  : 	print_errors = 0;
; 316  : 
; 317  :     if (argc < 1)

	cmp	edi, 1
	jl	$LN106@getopt_int

; 318  : 	return -1;
; 319  : 
; 320  :     optarg = NULL;
; 321  : 
; 322  :     if (optind == 0 || !__getopt_initialized)

	mov	esi, DWORD PTR _optind
	mov	DWORD PTR _optarg, 0
	test	esi, esi
	je	SHORT $LN99@getopt_int
	cmp	DWORD PTR ___getopt_initialized, 0
	jne	SHORT $LN12@getopt_int

; 323  :     {
; 324  : 	if (optind == 0)

	jmp	SHORT $LN14@getopt_int
$LN99@getopt_int:

; 325  : 	    optind = 1;	/* Don't scan ARGV[0], the program name.  */

	mov	DWORD PTR _optind, 1
$LN14@getopt_int:

; 326  : 	optstring = _getopt_initialize (argc, argv, optstring);

	push	ecx
	call	__getopt_initialize

; 327  : 	__getopt_initialized = 1;

	mov	esi, DWORD PTR _optind
	add	esp, 4
	mov	DWORD PTR _optstring$1$[ebp], eax
	mov	DWORD PTR ___getopt_initialized, 1
$LN12@getopt_int:

; 328  :     }
; 329  : 
; 330  :     /* Test whether ARGV[optind] points to a non-option argument.
; 331  :        Either it does not have option syntax, or there is an environment flag
; 332  :        from the shell indicating it is not an option.  The later information
; 333  :        is only used when the used in the GNU libc.  */
; 334  : #define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
; 335  : 
; 336  :     if (nextchar == NULL || *nextchar == '\0')

	mov	edx, DWORD PTR _nextchar
	test	edx, edx
	je	SHORT $LN16@getopt_int
	cmp	BYTE PTR [edx], 0
	jne	$LN15@getopt_int
$LN16@getopt_int:

; 337  :     {
; 338  : 	/* Advance to the next ARGV-element.  */
; 339  : 
; 340  : 	/* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
; 341  : 	   moved back by the user (who may also have changed the arguments).  */
; 342  : 	if (last_nonopt > optind)

	mov	eax, DWORD PTR _last_nonopt
	cmp	eax, esi

; 343  : 	    last_nonopt = optind;
; 344  : 	if (first_nonopt > optind)

	mov	ecx, DWORD PTR _first_nonopt
	cmovg	eax, esi
	cmp	ecx, esi
	mov	DWORD PTR _last_nonopt, eax
	cmovg	ecx, esi

; 345  : 	    first_nonopt = optind;
; 346  : 
; 347  : 	if (ordering == PERMUTE)

	cmp	DWORD PTR _ordering, 1
	mov	DWORD PTR _first_nonopt, ecx
	jne	SHORT $LN19@getopt_int

; 348  : 	{
; 349  : 	    /* If we have just processed some options following some non-options,
; 350  : 	       exchange them so that the options come first.  */
; 351  : 
; 352  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	cmp	ecx, eax
	je	SHORT $LN20@getopt_int
	cmp	eax, esi
	je	SHORT $LN83@getopt_int

; 353  : 		exchange ((char **) argv);

	mov	ecx, ebx
	call	_exchange
	mov	ecx, DWORD PTR _first_nonopt
	jmp	SHORT $LN83@getopt_int
$LN20@getopt_int:

; 354  : 	    else if (last_nonopt != optind)

	cmp	eax, esi
	cmovne	ecx, esi
	mov	DWORD PTR _first_nonopt, ecx
$LN83@getopt_int:

; 355  : 		first_nonopt = optind;
; 356  : 
; 357  : 	    /* Skip any additional non-options
; 358  : 	       and extend the range of non-options previously skipped.  */
; 359  : 
; 360  : 	    while (optind < argc && NONOPTION_P)

	cmp	esi, edi
	jge	SHORT $LN3@getopt_int
	npad	6
$LL2@getopt_int:
	mov	eax, DWORD PTR [ebx+esi*4]
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	SHORT $LN93@getopt_int
	cmp	BYTE PTR [eax+1], 0
	jne	SHORT $LN3@getopt_int
$LN93@getopt_int:

; 361  : 		optind++;

	inc	esi
	mov	DWORD PTR _optind, esi
	cmp	esi, edi
	jl	SHORT $LL2@getopt_int
$LN3@getopt_int:

; 362  : 	    last_nonopt = optind;

	mov	eax, esi
	mov	DWORD PTR _last_nonopt, eax
$LN19@getopt_int:

; 363  : 	}
; 364  : 
; 365  : 	/* The special ARGV-element `--' means premature end of options.
; 366  : 	   Skip it like a null option,
; 367  : 	   then exchange with previous non-options as if it were an option,
; 368  : 	   then skip everything else like a non-option.  */
; 369  : 
; 370  : 	if (optind != argc && !strcmp (argv[optind], "--"))

	cmp	esi, edi
	je	SHORT $LN98@getopt_int
	mov	edx, DWORD PTR [ebx+esi*4]
	mov	edi, OFFSET ??_C@_02BAABKJLB@?9?9@
	npad	4
$LL108@getopt_int:
	mov	bl, BYTE PTR [edx]
	cmp	bl, BYTE PTR [edi]
	mov	BYTE PTR tv930[ebp], bl
	mov	ebx, DWORD PTR _argv$1$[ebp]
	jne	SHORT $LN109@getopt_int
	cmp	BYTE PTR tv930[ebp], 0
	je	SHORT $LN110@getopt_int
	mov	bl, BYTE PTR [edx+1]
	cmp	bl, BYTE PTR [edi+1]
	mov	BYTE PTR tv931[ebp], bl
	mov	ebx, DWORD PTR _argv$1$[ebp]
	jne	SHORT $LN109@getopt_int
	add	edx, 2
	add	edi, 2
	cmp	BYTE PTR tv931[ebp], 0
	jne	SHORT $LL108@getopt_int
$LN110@getopt_int:
	xor	edx, edx
	jmp	SHORT $LN111@getopt_int
$LN109@getopt_int:
	sbb	edx, edx
	or	edx, 1
$LN111@getopt_int:
	test	edx, edx
	jne	SHORT $LN28@getopt_int

; 371  : 	{
; 372  : 	    optind++;

	inc	esi
	mov	DWORD PTR _optind, esi

; 373  : 
; 374  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	cmp	ecx, eax
	je	SHORT $LN97@getopt_int
	cmp	eax, esi
	je	SHORT $LN27@getopt_int

; 375  : 		exchange ((char **) argv);

	mov	ecx, ebx
	call	_exchange
	mov	ecx, DWORD PTR _first_nonopt
	jmp	SHORT $LN27@getopt_int
$LN97@getopt_int:

; 376  : 	    else if (first_nonopt == last_nonopt)
; 377  : 		first_nonopt = optind;

	mov	ecx, esi
	mov	DWORD PTR _first_nonopt, ecx
$LN27@getopt_int:

; 378  : 	    last_nonopt = argc;

	mov	eax, DWORD PTR _argc$1$[ebp]

; 379  : 
; 380  : 	    optind = argc;

	mov	esi, eax
	mov	DWORD PTR _last_nonopt, eax
$LN98@getopt_int:

; 381  : 	}
; 382  : 
; 383  : 	/* If we have done all the ARGV-elements, stop the scan
; 384  : 	   and back over any non-options that we skipped and permuted.  */
; 385  : 
; 386  : 	if (optind == argc)
; 387  : 	{
; 388  : 	    /* Set the next-arg-index to point at the non-options
; 389  : 	       that we previously skipped, so the caller will digest them.  */
; 390  : 	    if (first_nonopt != last_nonopt)

	cmp	ecx, eax
	cmovne	esi, ecx
	mov	DWORD PTR _optind, esi
$LN106@getopt_int:

; 401  : 		return -1;

	or	eax, -1
$LN1@getopt_int:

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@getopt_int:

; 391  : 		optind = first_nonopt;
; 392  : 	    return -1;
; 393  : 	}
; 394  : 
; 395  : 	/* If we have come to a non-option and did not permute it,
; 396  : 	   either stop the scan or describe it to the caller and pass it by.  */
; 397  : 
; 398  : 	if (NONOPTION_P)

	mov	eax, DWORD PTR [ebx+esi*4]
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	$LN31@getopt_int
	mov	cl, BYTE PTR [eax+1]
	test	cl, cl
	je	$LN31@getopt_int

; 403  : 	    return 1;
; 404  : 	}
; 405  : 
; 406  : 	/* We have found another option-ARGV-element.
; 407  : 	   Skip the initial punctuation.  */
; 408  : 
; 409  : 	nextchar = (argv[optind] + 1

	xor	edx, edx
	cmp	cl, 45					; 0000002dH
	sete	dl
	inc	edx
	add	edx, eax
	mov	DWORD PTR _nextchar, edx
$LN15@getopt_int:

; 410  : 		+ (intopts != NULL && argv[optind][1] == '-'));
; 411  :     }
; 412  : 
; 413  :     /* Decode the current option-ARGV-element.  */
; 414  : 
; 415  :     /* Check whether the ARGV-element is a int option.
; 416  : 
; 417  :        If int_only and the ARGV-element has the form "-f", where f is
; 418  :        a valid short option, don't consider it an abbreviated form of
; 419  :        a int option that starts with f.  Otherwise there would be no
; 420  :        way to give the -f short option.
; 421  : 
; 422  :        On the other hand, if there's a int option "fubar" and
; 423  :        the ARGV-element is "-fu", do consider that an abbreviation of
; 424  :        the int option, just like "--fu", and not "-f" with arg "u".
; 425  : 
; 426  :        This distinction seems to be the most useful approach.  */
; 427  : 
; 428  :     if (intopts != NULL
; 429  : 	    && (argv[optind][1] == '-'

	mov	eax, DWORD PTR [ebx+esi*4]
	cmp	BYTE PTR [eax+1], 45			; 0000002dH
	jne	$LN59@getopt_int

; 430  : 		|| (int_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
; 431  :     {
; 432  : 	char *nameend;
; 433  : 	const struct option *p;
; 434  : 	const struct option *pfound = NULL;
; 435  : 	int exact = 0;
; 436  : 	int ambig = 0;

	xor	eax, eax

; 437  : 	int indfound = -1;
; 438  : 	int option_index;
; 439  : 
; 440  : 	for (nameend = nextchar; *nameend && *nameend != '='; nameend++)

	mov	DWORD PTR _nameend$1$[ebp], edx
	mov	DWORD PTR _ambig$1$[ebp], eax
	xor	ebx, ebx
	mov	al, BYTE PTR [edx]
	mov	ecx, edx
	test	al, al
	je	SHORT $LN5@getopt_int
$LL6@getopt_int:
	cmp	al, 61					; 0000003dH
	je	SHORT $LN120@getopt_int
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL6@getopt_int
$LN120@getopt_int:
	mov	DWORD PTR _nameend$1$[ebp], ecx
$LN5@getopt_int:

; 441  : 	    /* Do nothing.  */ ;
; 442  : 
; 443  : 	/* Test all int options for either exact match
; 444  : 	   or abbreviated matches.  */
; 445  : 	for (p = intopts, option_index = 0; p->name; p++, option_index++)

	mov	ecx, DWORD PTR _intopts
	mov	edi, OFFSET _intopts
	test	ecx, ecx
	je	$LN45@getopt_int
	mov	esi, DWORD PTR _nameend$1$[ebp]
	npad	6
$LL9@getopt_int:

; 446  : 	    if (!strncmp (p->name, nextchar, nameend - nextchar))

	mov	eax, esi
	sub	eax, edx
	push	eax
	push	edx
	push	ecx
	call	_strncmp
	mov	edx, DWORD PTR _nextchar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@getopt_int

; 447  : 	    {
; 448  : 		if ((unsigned int) (nameend - nextchar)
; 449  : 			== (unsigned int) strlen (p->name))

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv934[ebp], eax
$LL112@getopt_int:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL112@getopt_int
	sub	ecx, DWORD PTR tv934[ebp]
	mov	eax, esi
	sub	eax, edx
	cmp	eax, ecx
	je	$LN86@getopt_int

; 455  : 		    break;
; 456  : 		}
; 457  : 		else if (pfound == NULL)

	test	ebx, ebx
	jne	SHORT $LN39@getopt_int

; 458  : 		{
; 459  : 		    /* First nonexact match found.  */
; 460  : 		    pfound = p;

	mov	ebx, edi

; 461  : 		    indfound = option_index;
; 462  : 		}

	jmp	SHORT $LN7@getopt_int
$LN39@getopt_int:

; 463  : 		else if (int_only
; 464  : 			|| pfound->has_arg != p->has_arg
; 465  : 			|| pfound->flag != p->flag
; 466  : 			|| pfound->val != p->val)

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [edi+12]
	je	SHORT $LN7@getopt_int
$LN42@getopt_int:

; 467  : 		    /* Second or later nonexact match found.  */
; 468  : 		    ambig = 1;

	mov	DWORD PTR _ambig$1$[ebp], 1
$LN7@getopt_int:

; 441  : 	    /* Do nothing.  */ ;
; 442  : 
; 443  : 	/* Test all int options for either exact match
; 444  : 	   or abbreviated matches.  */
; 445  : 	for (p = intopts, option_index = 0; p->name; p++, option_index++)

	mov	ecx, DWORD PTR [edi+16]
	add	edi, 16					; 00000010H
	test	ecx, ecx
	jne	SHORT $LL9@getopt_int
$LN107@getopt_int:

; 469  : 	    }
; 470  : 
; 471  : 	if (ambig && !exact)

	cmp	DWORD PTR _ambig$1$[ebp], 0
	je	SHORT $LN43@getopt_int
	test	ecx, ecx
	jne	SHORT $LN43@getopt_int

; 472  : 	{
; 473  : 	    if (print_errors)
; 474  : 	    {
; 475  : 		fprintf (stderr, _("%s: option `%s' is ambiguous\n"),

	mov	ecx, DWORD PTR _argv$1$[ebp]
	mov	eax, DWORD PTR _optind
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 476  : 			argv[0], argv[optind]);
; 477  : 	    }
; 478  : 	    nextchar += strlen (nextchar);

	mov	edx, DWORD PTR _nextchar
	add	esp, 16					; 00000010H
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL113@getopt_int:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL113@getopt_int
	sub	ecx, esi

; 479  : 	    optind++;
; 480  : 	    optopt = 0;
; 481  : 	    return '?';

	mov	eax, 63					; 0000003fH
	add	edx, ecx
	inc	DWORD PTR _optind
	mov	DWORD PTR _nextchar, edx

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@getopt_int:

; 450  : 		{
; 451  : 		    /* Exact match found.  */
; 452  : 		    pfound = p;

	mov	ebx, edi

; 453  : 		    indfound = option_index;
; 454  : 		    exact = 1;

	mov	ecx, 1
	jmp	SHORT $LN107@getopt_int
$LN43@getopt_int:

; 482  : 	}
; 483  : 
; 484  : 	if (pfound != NULL)

	mov	esi, DWORD PTR _optind
	test	ebx, ebx
	je	$LN45@getopt_int

; 485  : 	{
; 486  : 	    option_index = indfound;
; 487  : 	    optind++;
; 488  : 	    if (*nameend)

	mov	eax, DWORD PTR _nameend$1$[ebp]
	inc	esi
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR _optind, esi
	cmp	BYTE PTR [eax], 0
	je	$LN46@getopt_int

; 489  : 	    {
; 490  : 		/* Don't test has_arg with >, because some C compilers don't
; 491  : 		   allow it to be used on enums.  */
; 492  : 		if (pfound->has_arg)

	test	ecx, ecx
	je	SHORT $LN101@getopt_int

; 493  : 		    optarg = nameend + 1;

	inc	eax
	mov	DWORD PTR _optarg, eax
$LN55@getopt_int:

; 537  : 		}
; 538  : 	    }
; 539  : 	    nextchar += strlen (nextchar);

	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL116@getopt_int:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL116@getopt_int

; 540  : 	    if (intind != NULL)
; 541  : 		*intind = option_index;
; 542  : 	    if (pfound->flag)

	mov	eax, DWORD PTR [ebx+12]
	sub	ecx, esi
	add	edx, ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _nextchar, edx
	test	ecx, ecx
	je	$LN1@getopt_int

; 543  : 	    {
; 544  : 		*(pfound->flag) = pfound->val;

	mov	DWORD PTR [ecx], eax

; 545  : 		return 0;

	xor	eax, eax

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@getopt_int:

; 494  : 		else
; 495  : 		{
; 496  : 		    if (print_errors)
; 497  : 		    {
; 498  : 
; 499  : 			if (argv[optind - 1][1] == '-')

	mov	ecx, DWORD PTR _argv$1$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	eax
	mov	edx, DWORD PTR [ecx+esi*4-4]
	cmp	BYTE PTR [edx+1], 45			; 0000002dH
	jne	SHORT $LN51@getopt_int

; 500  : 			{
; 501  : 			    /* --option */
; 502  : 			    fprintf (stderr, _("\

	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 503  : 					%s: option `--%s' doesn't allow an argument\n"),
; 504  : 				    argv[0], pfound->name);
; 505  : 			}

	jmp	SHORT $LN52@getopt_int
$LN51@getopt_int:

; 506  : 			else
; 507  : 			{
; 508  : 			    /* +option or -option */
; 509  : 			    fprintf (stderr, _("\

	movsx	eax, BYTE PTR [edx]
	push	eax
	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H
$LN52@getopt_int:

; 510  : 					%s: option `%c%s' doesn't allow an argument\n"),
; 511  : 				    argv[0], argv[optind - 1][0], pfound->name);
; 512  : 			}
; 513  : 
; 514  : 		    }
; 515  : 
; 516  : 		    nextchar += strlen (nextchar);

	mov	edx, DWORD PTR _nextchar
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL114@getopt_int:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL114@getopt_int
	sub	ecx, esi

; 517  : 
; 518  : 		    optopt = pfound->val;
; 519  : 		    return '?';

	mov	eax, 63					; 0000003fH
	add	edx, ecx
	mov	DWORD PTR _nextchar, edx

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@getopt_int:

; 520  : 		}
; 521  : 	    }
; 522  : 	    else if (pfound->has_arg == 1)

	cmp	ecx, 1
	jne	$LN55@getopt_int

; 523  : 	    {
; 524  : 		if (optind < argc)

	mov	ecx, DWORD PTR _argv$1$[ebp]
	cmp	esi, DWORD PTR _argc$1$[ebp]
	jge	SHORT $LN102@getopt_int

; 525  : 		    optarg = argv[optind++];

	mov	eax, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR _optarg, eax
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _optind, eax
	jmp	$LN55@getopt_int
$LN102@getopt_int:

; 526  : 		else
; 527  : 		{
; 528  : 		    if (print_errors)
; 529  : 		    {
; 530  : 			fprintf (stderr,

	push	DWORD PTR [ecx+esi*4-4]
	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 531  : 				_("%s: option `%s' requires an argument\n"),
; 532  : 				argv[0], argv[optind - 1]);
; 533  : 		    }
; 534  : 		    nextchar += strlen (nextchar);

	mov	edx, DWORD PTR _nextchar
	add	esp, 16					; 00000010H
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
	npad	4
$LL115@getopt_int:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL115@getopt_int
	sub	ecx, esi

; 535  : 		    optopt = pfound->val;
; 536  : 		    return optstring[0] == ':' ? ':' : '?';

	mov	eax, 63					; 0000003fH
	add	edx, ecx
	mov	ecx, DWORD PTR _optstring$1$[ebp]
	mov	DWORD PTR _nextchar, edx
	mov	edx, 58					; 0000003aH
	cmp	BYTE PTR [ecx], dl
	cmove	eax, edx

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@getopt_int:

; 546  : 	    }
; 547  : 	    return pfound->val;
; 548  : 	}
; 549  : 
; 550  : 	/* Can't find it as a int option.  If this is not getopt_int_only,
; 551  : 	   or the option starts with '--' or is not a valid short
; 552  : 	   option, then it's an error.
; 553  : 	   Otherwise interpret it as a short option.  */
; 554  : 	if (!int_only || argv[optind][1] == '-'
; 555  : 		|| my_index (optstring, *nextchar) == NULL)
; 556  : 	{
; 557  : 	    if (print_errors)
; 558  : 	    {
; 559  : 
; 560  : 		if (argv[optind][1] == '-')

	mov	ecx, DWORD PTR _argv$1$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+esi*4]
	cmp	BYTE PTR [eax+1], 45			; 0000002dH
	jne	SHORT $LN62@getopt_int

; 561  : 		{
; 562  : 		    /* --option */
; 563  : 		    fprintf (stderr, _("%s: unrecognized option `--%s'\n"),

	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 564  : 			    argv[0], nextchar);
; 565  : 		}

	jmp	SHORT $LN63@getopt_int
$LN62@getopt_int:

; 566  : 		else
; 567  : 		{
; 568  : 		    /* +option or -option */
; 569  : 		    fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),

	movsx	eax, BYTE PTR [eax]
	push	eax
	push	DWORD PTR [ecx]
	push	OFFSET ??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H
$LN63@getopt_int:

; 570  : 			    argv[0], argv[optind][0], nextchar);
; 571  : 		}
; 572  : 
; 573  : 	    }
; 574  : 	    nextchar = (char *) "";
; 575  : 	    optind++;

	inc	DWORD PTR _optind

; 576  : 	    optopt = 0;
; 577  : 	    return '?';

	mov	eax, 63					; 0000003fH
	mov	DWORD PTR _nextchar, OFFSET ??_C@_00CNPNBAHC@@

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@getopt_int:

; 578  : 	}
; 579  :     }
; 580  : 
; 581  :     /* Look at and handle the next short option-character.  */
; 582  : 
; 583  :     {
; 584  : 	char c = *nextchar++;

	mov	al, BYTE PTR [edx]
	inc	edx

; 585  : 	char *temp = my_index (optstring, c);

	movsx	edi, al
	push	edi
	push	DWORD PTR _optstring$1$[ebp]
	mov	DWORD PTR tv923[ebp], eax
	mov	DWORD PTR _nextchar, edx
	call	_strchr

; 586  : 
; 587  : 	/* Increment `optind' when we start to process its last character.  */
; 588  : 	if (*nextchar == '\0')

	mov	edx, DWORD PTR _nextchar
	mov	esi, eax
	mov	ecx, DWORD PTR _optind
	add	esp, 8
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv961[ebp], al
	test	al, al
	jne	SHORT $LN64@getopt_int

; 589  : 	    ++optind;

	inc	ecx
	mov	DWORD PTR _optind, ecx
$LN64@getopt_int:

; 590  : 
; 591  : 	if (temp == NULL || c == ':')

	test	esi, esi
	je	$LN104@getopt_int
	mov	eax, DWORD PTR tv923[ebp]
	cmp	al, 58					; 0000003aH
	je	$LN104@getopt_int

; 600  : 	}
; 601  : #ifdef SPECIAL_TREATMENT_FOR_W
; 602  : 	/* Convenience. Treat POSIX -W foo same as int option --foo */
; 603  : 	if (temp[0] == 'W' && temp[1] == ';')
; 604  : 	{
; 605  : 	    char *nameend;
; 606  : 	    const struct option *p;
; 607  : 	    const struct option *pfound = NULL;
; 608  : 	    int exact = 0;
; 609  : 	    int ambig = 0;
; 610  : 	    int indfound = 0;
; 611  : 	    int option_index;
; 612  : 
; 613  : 	    /* This is an option that requires an argument.  */
; 614  : 	    if (*nextchar != '\0')
; 615  : 	    {
; 616  : 		optarg = nextchar;
; 617  : 		/* If we end this ARGV-element by taking the rest as an arg,
; 618  : 		   we must advance to the next element now.  */
; 619  : 		optind++;
; 620  : 	    }
; 621  : 	    else if (optind == argc)
; 622  : 	    {
; 623  : 		if (print_errors)
; 624  : 		{
; 625  : 		    /* 1003.2 specifies the format of this message.  */
; 626  : 		    fprintf (stderr, _("%s: option requires an argument -- %c\n"),
; 627  : 			    argv[0], c);
; 628  : 		}
; 629  : 		optopt = c;
; 630  : 		if (optstring[0] == ':')
; 631  : 		    c = ':';
; 632  : 		else
; 633  : 		    c = '?';
; 634  : 		return c;
; 635  : 	    }
; 636  : 	    else
; 637  : 		/* We already incremented `optind' once;
; 638  : 		   increment it again when taking next ARGV-elt as argument.  */
; 639  : 		optarg = argv[optind++];
; 640  : 
; 641  : 	    /* optarg is now the argument, see if it's in the
; 642  : 	       table of intopts.  */
; 643  : 
; 644  : 	    for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
; 645  : 		/* Do nothing.  */ ;
; 646  : 
; 647  : 	    /* Test all int options for either exact match
; 648  : 	       or abbreviated matches.  */
; 649  : 	    for (p = intopts, option_index = 0; p->name; p++, option_index++)
; 650  : 		if (!strncmp (p->name, nextchar, nameend - nextchar))
; 651  : 		{
; 652  : 		    if ((unsigned int) (nameend - nextchar) == strlen (p->name))
; 653  : 		    {
; 654  : 			/* Exact match found.  */
; 655  : 			pfound = p;
; 656  : 			indfound = option_index;
; 657  : 			exact = 1;
; 658  : 			break;
; 659  : 		    }
; 660  : 		    else if (pfound == NULL)
; 661  : 		    {
; 662  : 			/* First nonexact match found.  */
; 663  : 			pfound = p;
; 664  : 			indfound = option_index;
; 665  : 		    }
; 666  : 		    else
; 667  : 			/* Second or later nonexact match found.  */
; 668  : 			ambig = 1;
; 669  : 		}
; 670  : 	    if (ambig && !exact)
; 671  : 	    {
; 672  : 		if (print_errors)
; 673  : 		{
; 674  : 		    fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
; 675  : 			    argv[0], argv[optind]);
; 676  : 		}
; 677  : 		nextchar += strlen (nextchar);
; 678  : 		optind++;
; 679  : 		return '?';
; 680  : 	    }
; 681  : 	    if (pfound != NULL)
; 682  : 	    {
; 683  : 		option_index = indfound;
; 684  : 		if (*nameend)
; 685  : 		{
; 686  : 		    /* Don't test has_arg with >, because some C compilers don't
; 687  : 		       allow it to be used on enums.  */
; 688  : 		    if (pfound->has_arg)
; 689  : 			optarg = nameend + 1;
; 690  : 		    else
; 691  : 		    {
; 692  : 			if (print_errors)
; 693  : 			{
; 694  : 			    fprintf (stderr, _("\
; 695  : 					%s: option `-W %s' doesn't allow an argument\n"),
; 696  : 				    argv[0], pfound->name);
; 697  : 			}
; 698  : 
; 699  : 			nextchar += strlen (nextchar);
; 700  : 			return '?';
; 701  : 		    }
; 702  : 		}
; 703  : 		else if (pfound->has_arg == 1)
; 704  : 		{
; 705  : 		    if (optind < argc)
; 706  : 			optarg = argv[optind++];
; 707  : 		    else
; 708  : 		    {
; 709  : 			if (print_errors)
; 710  : 			{
; 711  : 			    fprintf (stderr,
; 712  : 				    _("%s: option `%s' requires an argument\n"),
; 713  : 				    argv[0], argv[optind - 1]);
; 714  : 			}
; 715  : 			nextchar += strlen (nextchar);
; 716  : 			return optstring[0] == ':' ? ':' : '?';
; 717  : 		    }
; 718  : 		}
; 719  : 		nextchar += strlen (nextchar);
; 720  : 		if (intind != NULL)
; 721  : 		    *intind = option_index;
; 722  : 		if (pfound->flag)
; 723  : 		{
; 724  : 		    *(pfound->flag) = pfound->val;
; 725  : 		    return 0;
; 726  : 		}
; 727  : 		return pfound->val;
; 728  : 	    }
; 729  : 	    nextchar = NULL;
; 730  : 	    return 'W';	/* Let the application handle it.   */
; 731  : 	}
; 732  : #endif
; 733  : 	if (temp[1] == ':')

	cmp	BYTE PTR [esi+1], 58			; 0000003aH
	jne	$LN70@getopt_int

; 734  : 	{
; 735  : 	    if (temp[2] == ':')

	cmp	BYTE PTR [esi+2], 58			; 0000003aH
	jne	SHORT $LN69@getopt_int

; 736  : 	    {
; 737  : 		/* This is an option that accepts an argument optionally.  */
; 738  : 		if (*nextchar != '\0')

	cmp	BYTE PTR tv961[ebp], 0
	jne	SHORT $LN123@getopt_int

; 739  : 		{
; 740  : 		    optarg = nextchar;
; 741  : 		    optind++;
; 742  : 		}
; 743  : 		else
; 744  : 		    optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 776  : 		nextchar = NULL;
; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	mov	DWORD PTR _nextchar, 0
	movsx	eax, al

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@getopt_int:

; 745  : 		nextchar = NULL;
; 746  : 	    }
; 747  : 	    else
; 748  : 	    {
; 749  : 		/* This is an option that requires an argument.  */
; 750  : 		if (*nextchar != '\0')

	cmp	BYTE PTR tv961[ebp], 0
	je	SHORT $LN73@getopt_int
$LN123@getopt_int:

; 776  : 		nextchar = NULL;
; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	mov	DWORD PTR _optarg, edx
	jmp	SHORT $LN122@getopt_int
$LN73@getopt_int:

; 751  : 		{
; 752  : 		    optarg = nextchar;
; 753  : 		    /* If we end this ARGV-element by taking the rest as an arg,
; 754  : 		       we must advance to the next element now.  */
; 755  : 		    optind++;
; 756  : 		}
; 757  : 		else if (optind == argc)

	cmp	ecx, DWORD PTR _argc$1$[ebp]
	jne	SHORT $LN75@getopt_int

; 758  : 		{
; 759  : 		    if (print_errors)
; 760  : 		    {
; 761  : 			/* 1003.2 specifies the format of this message.  */
; 762  : 			fprintf (stderr,

	push	edi
	push	DWORD PTR [ebx]
	push	OFFSET ??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 763  : 				_("%s: option requires an argument -- %c\n"),
; 764  : 				argv[0], c);
; 765  : 		    }
; 766  : 		    optopt = c;
; 767  : 		    if (optstring[0] == ':')
; 768  : 			c = ':';
; 769  : 		    else
; 770  : 			c = '?';
; 771  : 		}

	mov	ecx, DWORD PTR _optstring$1$[ebp]
	mov	eax, 58					; 0000003aH
	add	esp, 16					; 00000010H

; 776  : 		nextchar = NULL;
; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	mov	DWORD PTR _nextchar, 0
	mov	edx, 63					; 0000003fH
	cmp	BYTE PTR [ecx], al
	cmovne	eax, edx
	movsx	eax, al

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@getopt_int:

; 772  : 		else
; 773  : 		    /* We already incremented `optind' once;
; 774  : 		       increment it again when taking next ARGV-elt as argument.  */
; 775  : 		    optarg = argv[optind++];

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR _optarg, eax
	mov	eax, DWORD PTR tv923[ebp]
$LN122@getopt_int:

; 776  : 		nextchar = NULL;
; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	inc	ecx
	mov	DWORD PTR _nextchar, 0
	mov	DWORD PTR _optind, ecx
$LN70@getopt_int:
	movsx	eax, al

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN104@getopt_int:

; 592  : 	{
; 593  : 	    if (print_errors)
; 594  : 	    {
; 595  : 		    /* 1003.2 specifies the format of this message.  */
; 596  : 		    fprintf (stderr, _("%s: illegal option -- %c\n"), argv[0], c);

	push	edi
	push	DWORD PTR [ebx]
	push	OFFSET ??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 597  : 	    }
; 598  : 	    optopt = c;
; 599  : 	    return '?';

	mov	eax, 63					; 0000003fH

; 780  :     }
; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@getopt_int:

; 399  : 	{
; 400  : 	    if (ordering == REQUIRE_ORDER)

	cmp	DWORD PTR _ordering, 0
	je	$LN106@getopt_int

; 402  : 	    optarg = argv[optind++];

	inc	esi
	mov	DWORD PTR _optarg, eax

; 780  :     }
; 781  : }

	pop	edi
	mov	DWORD PTR _optind, esi
	mov	eax, 1
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\sharksouth\OneDrive - bupt.edu.cn\学习资料\计算机网络\课程实验\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT _getopt_int
_TEXT	SEGMENT
_options$dead$ = 8					; size = 4
_int_options$dead$ = 12					; size = 4
_opt_index$dead$ = 16					; size = 4
_getopt_int PROC					; COMDAT
; _argc$ = ecx
; _argv$ = edx

; 792  :     return _getopt_internal (argc, argv, options, int_options, opt_index, 0);

	sub	esp, 16					; 00000010H
	call	__getopt_internal
	add	esp, 16					; 00000010H

; 793  : }

	ret	0
_getopt_int ENDP
_TEXT	ENDS
END
